<!DOCTYPE html>
<html lang="en">
<head>
  <!--
    MIT License
    
    Copyright (c) 2025 NQR
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
  -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SpectroGhost</title>
  <meta name="description" content="High resolution, zoomable spectrogram creator. Runs fully in-browser.">
  
  <!-- Favicon links -->
  <link rel="icon" type="image/png" sizes="16x16" href="assets/images/favicon-16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="assets/images/favicon-32x32.png">
  <link rel="apple-touch-icon" sizes="180x180" href="assets/images/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="assets/images/android-chrome-192x192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="assets/images/android-chrome-512x512.png">
  
  <style>
    /* ============================================
       CSS VARIABLES
       ============================================ */
    :root {
      --bg: #0c1020;
      --card: #151c3b;
      --ink: #eef1ff;
      --dim: #b9c6ef;
      --border: #2b3868;
      --accent: #1fc9aa;
      --accent-hover: #18b79a;
      --accent-dark: #17b399;
      --input-bg: #0f1432;
    }

    /* ============================================
       BASE STYLES
       ============================================ */
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      min-height: 100vh;
    }

    h2 {
      margin: 16px 0 8px;
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    h3 {
      margin: 0 0 12px 0;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.5px;
      color: var(--accent);
      text-transform: uppercase;
      text-align: left;
    }

    /* ============================================
       CONTROLS SECTION
       ============================================ */
    .controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 92vw;
      max-width: 760px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    .control-section {
      width: 100%;
      padding: 16px 0;
      border-bottom: 1px solid var(--border);
    }

    .control-section:last-of-type {
      border-bottom: none;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 16px;
      justify-content: center;
      align-items: flex-end;
    }

    /* ============================================
       FORM ELEMENTS
       ============================================ */
    label {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
      font-weight: bold;
      color: var(--dim);
      text-align: center;
      align-items: center;
      cursor: default;
    }

    label.clickable {
      cursor: pointer;
    }

    label.clickable:hover {
      color: var(--accent);
    }

    label.inline {
      flex-direction: row;
      align-items: center;
      gap: 8px;
    }

    input[type="number"],
    input[type="file"],
    select {
      background: var(--input-bg);
      border: 1px solid var(--border);
      color: var(--ink);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 14px;
      min-width: 100px;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    input[type="number"]:focus,
    input[type="file"]:focus,
    select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(31, 201, 170, 0.1);
    }

    input[type="file"] {
      cursor: pointer;
      padding: 8px 12px;
      width: auto;
      min-width: 300px;
    }

    /* Modern browsers (Chrome, Edge, Firefox, Safari 14+) */
    input[type="file"]::file-selector-button {
      background: var(--accent);
      color: #0b0f14;
      border: 1px solid var(--accent-dark);
      border-radius: 8px;
      padding: 10px 16px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.3px;
      transition: all 0.15s ease;
      box-shadow: 0 2px 4px rgba(31, 201, 170, 0.2);
      margin-right: 10px; /* space before filename text */
    }
    
    /* Hover/active to match your button styles */
    input[type="file"]::file-selector-button:hover {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(31, 201, 170, 0.3);
    }
    input[type="file"]::file-selector-button:active {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(31, 201, 170, 0.2);
    }
    
    /* Safari <14 (legacy WebKit fallback) */
    input[type="file"]::-webkit-file-upload-button {
      background: var(--accent);
      color: #0b0f14;
      border: 1px solid var(--accent-dark);
      border-radius: 8px;
      padding: 10px 16px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.3px;
      transition: all 0.15s ease;
      box-shadow: 0 2px 4px rgba(31, 201, 170, 0.2);
      margin-right: 10px;
    }
    input[type="file"]::-webkit-file-upload-button:hover {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(31, 201, 170, 0.3);
    }
    input[type="file"]::-webkit-file-upload-button:active {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(31, 201, 170, 0.2);
    }

    input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
      cursor: pointer;
      margin: 0;
    }

    /* Colormap Radio Button List */
    .colormap-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      width: 220px;
      margin: 0 auto;
    }

    .colormap-option {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      padding: 4px 6px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .colormap-option:hover {
      background: rgba(31, 201, 170, 0.1);
    }

    .colormap-option input[type="radio"] {
      cursor: pointer;
      accent-color: var(--accent);
      flex-shrink: 0;
      margin: 0;
    }

    .colormap-option input[type="radio"]:checked + .colormap-name {
      color: var(--accent);
      font-weight: 600;
    }

    .colormap-name {
      text-align: center;
      font-size: 13px;
      font-weight: 600;
      color: var(--ink);
      width: 65px;
      flex-shrink: 0;
    }

    .option-gradient {
      height: 8px;
      border-radius: 2px;
      width: 90px;
      flex-shrink: 0;
      border: 0px solid transparent;
    }

    .gradient-grayscale {
      background: linear-gradient(to right, #ffffff, #000000) !important;
    }
    
    .gradient-viridis {
      background: linear-gradient(to right, #440154, #3b528b, #21918c, #5ec962, #fde725) !important;
    }
    
    .gradient-plasma {
      background: linear-gradient(to right, #0d0887, #7e03a8, #cc4778, #f89540, #f0f921) !important;
    }
    
    .gradient-inferno {
      background: linear-gradient(to right, #000004, #420a68, #932667, #dd513a, #fca50a, #fcffa4) !important;
    }
    
    .gradient-magma {
      background: linear-gradient(to right, #000004, #3b0f70, #8c2981, #de4968, #fe9f6d, #fcfdbf) !important;
    }
    
    .gradient-jet {
      background: linear-gradient(to right, #00007f, #0000ff, #00ffff, #00ff00, #ffff00, #ff0000, #7f0000) !important;
    }
    
    .gradient-hot {
      background: linear-gradient(to right, #000000, #ff0000, #ffff00, #ffffff) !important;
    }
    
    .gradient-cool {
      background: linear-gradient(to right, #00ffff, #ff00ff) !important;
    }
    
    .gradient-parula {
      background: linear-gradient(to right, #352a87, #0f5cdd, #00a6ff, #ffed00, #ff4d00) !important;
    }

    /* ============================================
       BUTTONS
       ============================================ */
    button {
      background: var(--accent);
      color: #0b0f14;
      border: 1px solid var(--accent-dark);
      border-radius: 8px;
      padding: 10px 16px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.3px;
      transition: all 0.15s ease;
      box-shadow: 0 2px 4px rgba(31, 201, 170, 0.2);
    }

    button:hover:not(:disabled) {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(31, 201, 170, 0.3);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(31, 201, 170, 0.2);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* ============================================
       SPECTROGRAM DISPLAY
       ============================================ */
    .spec-container {
      width: 92vw;
      max-width: 1400px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      margin: 0 0 20px 0;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    .spec-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    .spec-title {
      font-size: 15px;
      font-weight: 600;
      color: var(--ink);
    }

    .spec-info {
      font-size: 13px;
      color: var(--dim);
      font-variant-numeric: tabular-nums;
    }

    .spec-wrap {
      position: relative;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #0f1432;
      height: 520px;
      cursor: grab;
    }

    .spec-wrap:active {
      cursor: grabbing;
    }

    .spec-inner {
      position: relative;
      height: 100%;
    }

    canvas {
      image-rendering: pixelated;
    }

    /* ============================================
       STATUS & INFO
       ============================================ */
    .status-bar {
      font-size: 13px;
      color: var(--dim);
    }

    .help-text {
      font-size: 12px;
      color: var(--dim);
      margin-top: 12px;
      line-height: 1.5;
    }

    /* ============================================
       LICENSE FOOTER
       ============================================ */
    .license-footer {
      margin-top: auto;
      margin-bottom: 20px;
      padding: 10px;
      font-size: 11px;
      color: var(--dim);
      opacity: 0.7;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .license-footer:hover {
      opacity: 1;
    }

    .license-modal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--card);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0,0,0,.6);
      z-index: 1000;
    }

    .license-modal.show {
      display: block;
    }

    .license-modal h3 {
      margin-top: 0;
      color: var(--ink);
      text-align: center;
      text-transform: none;
    }

    .license-modal pre {
      white-space: pre-wrap;
      font-size: 11px;
      line-height: 1.5;
      color: var(--dim);
      text-align: center;
    }

    .license-modal-close {
      float: right;
      cursor: pointer;
      font-size: 24px;
      color: var(--dim);
      transition: color 0.2s ease;
    }

    .license-modal-close:hover {
      color: var(--ink);
    }

    .license-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 999;
    }

    .license-overlay.show {
      display: block;
    }

    /* ============================================
       RESPONSIVE DESIGN
       ============================================ */
    @media (max-width: 640px) {
      .controls, .spec-container {
        padding: 16px 12px;
        width: 95vw;
      }

      .row {
        gap: 8px 12px;
      }

      .control-section .row > label {
        align-items: center;  /* centers the input under the text */
        text-align: center;   /* centers the label text iteself */
      }

      label {
        font-size: 12px;
        font-weight: 600;
      }

      input[type="number"],
      select {
        font-size: 13px;
        padding: 5px 7px;
        min-width: 80px;
      }

      input[type="file"] {
        margin: 8px;
        padding: 8px 12px;
        background: var(--input-bg);
        border: 1px solid var(--border);
        border-radius: 8px;
        color: var(--ink);
        cursor: pointer;
        min-width: 200px;
        font-size: 14px;
      }

      button {
        padding: 8px 14px;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <img src="assets/images/logo.png" alt="SpectroGhost Logo" style="max-width: 200px; height: auto; margin: 20px 0 10px;">
  <h2>SpectroGhost</h2>
  <p style="color: var(--dim); font-size: 14px; margin: -5px 0 15px; font-style: italic;">A lightweight spectrogram creator by NQR</p>
  
  <!-- Controls -->
  <div class="controls">
    <!-- File Input -->
    <div class="control-section">
      <h3>🎵 Audio Input</h3>
      <div class="row">
        <input type="file" id="fileIn" accept="audio/*">
      </div>
    </div>

    <!-- Basic Settings (combined with frequency range and advanced) -->
    <div class="control-section">
      <h3>⚙️ Basic Settings</h3>
      <div class="row">
        <label>FFT Size
          <select id="fftSize">
            <option>256</option>
            <option>512</option>
            <option>1024</option>
            <option>2048</option>
            <option selected>4096</option>
            <option>8192</option>
            <option>16384</option>
          </select>
        </label>
        
        <label>Dynamic Range (dB)
          <input type="number" id="dynRange" value="80" min="20" max="140" step="1">
        </label>
        
        <label>Scale
          <select id="scale">
            <option value="linear" selected>Linear</option>
            <option value="log">Log</option>
            <option value="mel">Mel</option>
            <option value="bark">Bark</option>
          </select>
        </label>
      </div>
      <div class="row">
        <label>Min Frequency (Hz)
          <input type="number" id="minHz" value="0" min="0" step="1">
        </label>
        
        <label>Max Frequency (Hz)
          <input type="number" id="maxHz" value="0" min="0" step="1">
        </label>
        
      </div>
    </div>

    <!-- Display Settings (with colormap) -->
    <div class="control-section">
      <h3>🖼️ Display Settings</h3>
      <div class="row">
        <label class="clickable" id="pxHLabel" title="Double-click to set ideal value">Height (px)
          <input type="number" id="pxH" value="480" min="200" max="4000" step="10">
        </label>
        
        <label class="clickable" id="pxPerSecLabel" title="Double-click to set ideal value">Pixels / Second
          <input type="number" id="pxPerSec" value="300" min="50" max="4000" step="10">
        </label>

        <button id="btnMakeInvertible">Optimize</button>
      </div>
      
      <div class="row" style="margin-top: 12px;">
        <div style="display: flex; flex-direction: column; align-items: center; gap: 12px;">
          <div style="font-size: 13px; font-weight: bold; color: var(--dim);">Colormap</div>
          <div class="colormap-list">
            <label class="colormap-option">
              <input type="radio" name="colormap" value="grayscale" checked>
              <span class="colormap-name">Grayscale</span>
              <div class="option-gradient gradient-grayscale"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="viridis">
              <span class="colormap-name">Viridis</span>
              <div class="option-gradient gradient-viridis"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="plasma">
              <span class="colormap-name">Plasma</span>
              <div class="option-gradient gradient-plasma"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="inferno">
              <span class="colormap-name">Inferno</span>
              <div class="option-gradient gradient-inferno"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="magma">
              <span class="colormap-name">Magma</span>
              <div class="option-gradient gradient-magma"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="jet">
              <span class="colormap-name">Jet</span>
              <div class="option-gradient gradient-jet"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="hot">
              <span class="colormap-name">Hot</span>
              <div class="option-gradient gradient-hot"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="cool">
              <span class="colormap-name">Cool</span>
              <div class="option-gradient gradient-cool"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="parula">
              <span class="colormap-name">Parula</span>
              <div class="option-gradient gradient-parula"></div>
            </label>
          </div>
          
          <label class="clickable inline">
            <input type="checkbox" id="invertColors">
            Invert Colors
          </label>
        </div>
        
        <!-- Hidden select for compatibility -->
        <select id="colormap" style="display: none;">
          <option value="grayscale">Grayscale</option>
          <option value="viridis">Viridis</option>
          <option value="plasma">Plasma</option>
          <option value="inferno">Inferno</option>
          <option value="magma">Magma</option>
          <option value="jet">Jet</option>
          <option value="hot">Hot</option>
          <option value="cool">Cool</option>
          <option value="parula">Parula</option>
        </select>
      </div>
    </div>

    <!-- Action Buttons -->
    <div class="control-section">
      <div class="row" style="gap: 12px;">
        <button id="btnRenderNow" style="display:none;">Render Now</button>
        <button id="btnDownload" disabled>Export PNG</button>
      </div>
      <div id="heavyNote" style="display:none; margin-top: 12px;">
        <small style="color: #f89540;">⚠️ Auto-render disabled for large job. Use "Render Now" or lower resolution.</small>
      </div>
      <div class="help-text">
        💡 <strong>Tip:</strong> Ctrl + Mouse wheel = zoom • Drag to pan • Double-click to reset
      </div>
    </div>
  </div>

  <!-- Spectrogram Display -->
  <div class="spec-container">
    <div class="spec-header">
      <div class="spec-title">📈 Spectrogram</div>
      <div class="status-bar" id="status">Ready • Load an audio file to begin</div>
      <div class="spec-info" id="cursor">00:00.000 • 0 Hz</div>
    </div>
    <div class="spec-wrap" id="specWrap">
      <div class="spec-inner" id="specInner">
        <canvas id="specCanvas"></canvas>
      </div>
    </div>
  </div>

  <!-- License Footer -->
  <div class="license-footer" id="licenseLink">
    © 2025 NQR • Licensed under MIT • Click for details
  </div>

  <!-- License Modal -->
  <div class="license-overlay" id="licenseOverlay"></div>
  <div class="license-modal" id="licenseModal">
    <span class="license-modal-close" id="licenseClose">&times;</span>
    <h3>MIT License</h3>
    <pre>Copyright (c) 2025 NQR

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</pre>
  </div>

  <!-- Scale Warning Modal -->
  <div class="license-overlay" id="scaleWarningOverlay"></div>
  <div class="license-modal" id="scaleWarningModal">
    <span class="license-modal-close" id="scaleWarningClose">&times;</span>
    <h3>Optimization Not Available</h3>
    <p style="color: var(--dim); text-align: center; line-height: 1.6; margin: 20px 0;">
      The "Optimize" feature is only available for <strong>Linear</strong> frequency scale.<br><br>
      Perceptual scales (Log, Mel, Bark) compress frequency information non-uniformly, 
      making perfect reconstruction optimization incompatible with reasonable image dimensions.<br><br>
      To use optimization, please switch to <strong>Linear</strong> scale first.
    </p>
  </div>
  <script>
  "use strict";
  
  /* ============================================
     COLORMAP RADIO BUTTON HANDLER
     ============================================ */
  (function initColormapRadios() {
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initRadios);
    } else {
      initRadios();
    }
    
    function initRadios() {
      const radios = document.querySelectorAll('input[name="colormap"]');
      const hiddenSelect = document.getElementById('colormap');
      
      if(!hiddenSelect) return;
      
      radios.forEach(radio => {
        radio.addEventListener('change', (e) => {
          if (e.target.checked) {
            // Update hidden select to maintain existing functionality
            hiddenSelect.value = e.target.value;
            
            // Trigger change event on the hidden select
            const event = new Event('change', { bubbles: true });
            hiddenSelect.dispatchEvent(event);
          }
        });
      });
      
      // Initialize: sync hidden select value with checked radio
      const checkedRadio = document.querySelector('input[name="colormap"]:checked');
      if(checkedRadio) {
        hiddenSelect.value = checkedRadio.value;
      }
    }
  })();
  
  /* ============================================
     UTILITY FUNCTIONS
     ============================================ */
  
  /**
   * Format seconds as MM:SS.mmm
   * @param {number} s - Time in seconds
   * @returns {string} Formatted time string
   */
  const fmtTime = s => {
    const ms = Math.round((s%1)*1000).toString().padStart(3,'0');
    const m = Math.floor(s/60);
    const sec = Math.floor(s%60).toString().padStart(2,'0');
    return `${m}:${sec}.${ms}`;
  };
  
  /**
   * Generate Hann window for FFT analysis
   * @param {number} N - Window length
   * @returns {Float32Array} Hann window coefficients
   */
  function hann(N){
    const w = new Float32Array(N);
    for(let n=0; n<N; n++){
      w[n] = 0.5 * (1 - Math.cos(2*Math.PI*n/(N-1)));
    }
    return w;
  }

  /**
   * Convert Hz to Mel scale
   */
  function hzToMel(hz){
    return 2595 * Math.log10(1 + hz / 700);
  }
  
  /**
   * Convert Mel to Hz
   */
  function melToHz(mel){
    return 700 * (Math.pow(10, mel / 2595) - 1);
  }
  
  /**
   * Convert Hz to Bark scale
   */
  function hzToBark(hz){
    return 13 * Math.atan(0.00076 * hz) + 3.5 * Math.atan(Math.pow(hz / 7500, 2));
  }
  
  /**
   * Convert Bark to Hz
   */
  function barkToHz(bark){
    return 600 * Math.sinh(bark / 6);
  }
  
  /**
   * In-place radix-2 Cooley-Tukey FFT
   * @param {number} N - FFT size (must be power of 2)
   * @param {Float32Array} re - Real components (modified in-place)
   * @param {Float32Array} im - Imaginary components (modified in-place)
   */
  function FFT(N, re, im){
    // Bit-reversal permutation
    let i=0, j=0;
    for(i=0; i<N; i++){
      if(j>i){
        [re[i],re[j]] = [re[j],re[i]];
        [im[i],im[j]] = [im[j],im[i]];
      }
      let m = N>>1;
      while(m>=1 && j>=m){
        j -= m;
        m >>= 1;
      }
      j += m;
    }
    
    // FFT computation
    for(let len=2; len<=N; len<<=1){
      const ang = -2*Math.PI/len;
      const wlenr = Math.cos(ang);
      const wleni = Math.sin(ang);
      for(let i=0; i<N; i+=len){
        let wr=1, wi=0;
        for(let k=0; k<len/2; k++){
          const u_r = re[i+k];
          const u_i = im[i+k];
          const v_r = re[i+k+len/2]*wr - im[i+k+len/2]*wi;
          const v_i = re[i+k+len/2]*wi + im[i+k+len/2]*wr;
          re[i+k] = u_r + v_r;
          im[i+k] = u_i + v_i;
          re[i+k+len/2] = u_r - v_r;
          im[i+k+len/2] = u_i - v_i;
          const nwr = wr*wlenr - wi*wleni;
          wi = wr*wleni + wi*wlenr;
          wr = nwr;
        }
      }
    }
  }
  
  /* ============================================
     COLORMAPS (256-entry LUTs)
     ============================================ */
  
  // Global LUT array (RGBA, 256 entries)
  let LUT = new Uint8ClampedArray(256*4);
  
  // Grayscale (default)
  function buildGray(){
    for(let i=0; i<256; i++){
      LUT[i*4]=i; LUT[i*4+1]=i; LUT[i*4+2]=i; LUT[i*4+3]=255;
    }
  }
  
  // Helper: linear interpolate between colors
  function lerpColor(c0, c1, t){
    const r = Math.round(c0[0]+(c1[0]-c0[0])*t);
    const g = Math.round(c0[1]+(c1[1]-c0[1])*t);
    const b = Math.round(c0[2]+(c1[2]-c0[2])*t);
    return [r,g,b];
  }
  
  // Build gradient from key colors
  function buildGradient(colors){
    const n = colors.length-1;
    for(let i=0; i<256; i++){
      const t = 1 - (i / 255);
      const s = t*n;
      const idx = Math.min(Math.floor(s), n-1);
      const frac = s - idx;
      const c = lerpColor(colors[idx], colors[idx+1], frac);
      LUT[i*4]=c[0]; LUT[i*4+1]=c[1]; LUT[i*4+2]=c[2]; LUT[i*4+3]=255;
    }
  }
  
  // Colormap definitions
  const COLORMAPS = {
    grayscale: buildGray,
    viridis: ()=>buildGradient([[68,1,84],[59,82,139],[33,145,140],[94,201,98],[253,231,37]]),
    plasma: ()=>buildGradient([[13,8,135],[126,3,168],[204,71,120],[248,149,64],[240,249,33]]),
    inferno: ()=>buildGradient([[0,0,4],[66,10,104],[147,81,58],[221,81,10],[252,255,164]]),
    magma: ()=>buildGradient([[0,0,4],[59,15,112],[140,41,129],[222,73,104],[254,159,109],[252,253,191]]),
    jet: ()=>buildGradient([[0,0,127],[0,0,255],[0,255,255],[0,255,0],[255,255,0],[255,0,0],[127,0,0]]),
    hot: ()=>buildGradient([[0,0,0],[255,0,0],[255,255,0],[255,255,255]]),
    cool: ()=>buildGradient([[0,255,255],[255,0,255]]),
    parula: ()=>buildGradient([[53,42,135],[15,92,221],[0,166,255],[255,237,0],[255,77,0]])
  };
  
  // Initialize colormap
  buildGray();
  
  /* ============================================
     ELEMENT REFERENCES
     ============================================ */
  const els = {
    fileIn: document.getElementById('fileIn'),
    fftSize: document.getElementById('fftSize'),
    dynRange: document.getElementById('dynRange'),
    scale: document.getElementById('scale'),
    minHz: document.getElementById('minHz'),
    maxHz: document.getElementById('maxHz'),
    pxH: document.getElementById('pxH'),
    pxPerSec: document.getElementById('pxPerSec'),
    colormap: document.getElementById('colormap'),
    btnMakeInvertible: document.getElementById('btnMakeInvertible'),
    btnRenderNow: document.getElementById('btnRenderNow'),
    btnDownload: document.getElementById('btnDownload'),
    heavyNote: document.getElementById('heavyNote'),
    status: document.getElementById('status'),
    cursor: document.getElementById('cursor'),
    specWrap: document.getElementById('specWrap'),
    cSpec: document.getElementById('specCanvas'),
    pxHLabel: document.getElementById('pxHLabel'),
    pxPerSecLabel: document.getElementById('pxPerSecLabel')
  };
  
  /* ============================================
     GLOBAL STATE
     ============================================ */
  let audioBuffer = null;
  let meta = null;
  let offscreen = null;
  let zoomX = 1, zoomY = 1;
  let wasOptimized = false;
  
  /* ============================================
     INVERTIBLE MODE FUNCTIONS
     ============================================ */
  
  /**
   * Compute invertible layout parameters
   * @returns {Object} Invertible parameters
   */
  function computeInvertible(){
    const sr = (meta && meta.sampleRate) || 48000;
    const N = Number(els.fftSize.value)||2048;
    const hop = Math.max(1, Math.round(N/2));
    const maxHz = Number(els.maxHz.value)||Math.floor(sr/2);
    const minHz = Number(els.minHz.value);
    const bins = Math.max(1, Math.floor((maxHz - minHz) / (sr / N)));
    const height = bins;
    const pxPerSec = sr / hop;
    return {sr, N, hop, minHz, maxHz, height, pxPerSec};
  }

  /**
   * Apply invertible configuration
   */
  function applyInvertibleOnce(){
    wasOptimized = true;
    const inv = computeInvertible();
    if(els.minHz) els.minHz.value = inv.minHz;
    if(els.maxHz) els.maxHz.value = inv.maxHz;
    if(els.pxH) els.pxH.value = inv.height;
    if(els.pxPerSec) els.pxPerSec.value = inv.pxPerSec.toFixed(2);
    
    scheduleRender();
  }
  
  // Make Invertible button handler
  if(els.btnMakeInvertible){
    els.btnMakeInvertible.addEventListener('click', ()=>{
      const currentScale = els.scale ? els.scale.value : 'linear';
      if(currentScale !== 'linear'){
        // Show warning modal for non-linear scales
        if(window.showScaleWarning) window.showScaleWarning();
        return;
      }
      applyInvertibleOnce();
      els.status.textContent = 'Optimized dimensions set';
    });
  }
  
  // Double-click label handlers to set ideal values
  if(els.pxHLabel){
    els.pxHLabel.addEventListener('dblclick', ()=>{
      const inv = computeInvertible();
      els.pxH.value = inv.height;
      if(audioBuffer) scheduleRender();
    });
  }
  
  if(els.pxPerSecLabel){
    els.pxPerSecLabel.addEventListener('dblclick', ()=>{
      const inv = computeInvertible();
      els.pxPerSec.value = inv.pxPerSec.toFixed(2);
      if(audioBuffer) scheduleRender();
    });
  }
  
  // Prevent inputs from triggering the label double-click behavior
  [els.pxH, els.pxPerSec].forEach(input => {
    input.addEventListener('dblclick', e => {
      e.stopPropagation(); // stops bubbling up to label
    });
  });

  // Reset wasOptimized when user manually changes dimensions or scale
  if(els.pxH){
    els.pxH.addEventListener('input', ()=>{
      wasOptimized = false;
    });
  }
  
  if(els.pxPerSec){
    els.pxPerSec.addEventListener('input', ()=>{
      wasOptimized = false;
    });
  }

  if(els.scale){
    els.scale.addEventListener('change', ()=>{
      wasOptimized = false;
    });
  }

  /* ============================================
     COLORMAP CHANGE HANDLER
     ============================================ */
  if(els.colormap){
    els.colormap.addEventListener('change', ()=>{
      const cm = els.colormap.value;
      if(COLORMAPS[cm]){
        COLORMAPS[cm]();
        if(offscreen && offscreen.gray8){
          renderOffscreenToCanvas();
        }
      }
    });
  }
  
  /* ============================================
     INVERT COLORS HANDLER
     ============================================ */
  const invertChk = document.getElementById('invertColors');
  if(invertChk){
    invertChk.addEventListener('change', ()=>{
      if(offscreen && offscreen.gray8){
        renderOffscreenToCanvas();
      }
    });
  }
  
  /* ============================================
     FILE INPUT HANDLER
     ============================================ */
  if(els.fileIn){
    els.fileIn.addEventListener('change', async (e)=>{
      const file = e.target.files[0];
      if(!file) return;
      
      try{
        els.status.textContent = 'Loading audio...';
        const ab = await file.arrayBuffer();
        const actx = new (window.AudioContext || window.webkitAudioContext)();
        audioBuffer = await actx.decodeAudioData(ab);
        
        meta = {
          sampleRate: audioBuffer.sampleRate,
          duration: audioBuffer.duration,
          channels: audioBuffer.numberOfChannels
        };
        wasOptimized = false;
        
        els.status.textContent = `Loaded: ${meta.duration.toFixed(2)}s, ${meta.sampleRate}Hz, ${meta.channels}ch`;
        
        // Auto-set maxHz if 0
        if(Number(els.maxHz.value)===0){
          els.maxHz.value = String(Math.floor(meta.sampleRate/2));
        }
        
        // Trigger render
        scheduleRender();
      }catch(err){
        els.status.textContent = 'Error loading audio: ' + err.message;
        console.error(err);
      }
    });
  }
  
  /* ============================================
     RENDER SCHEDULING
     ============================================ */
  let renderTimeout = null;
  
  function scheduleRender(){
    if(renderTimeout) clearTimeout(renderTimeout);
    
    if(!audioBuffer) return;
    
    // Check if job is large
    const w = Math.ceil(meta.duration * Number(els.pxPerSec.value));
    const h = Number(els.pxH.value);
    const isHeavy = (w*h > 4000000);
    
    if(isHeavy){
      els.btnRenderNow.style.display = 'inline-block';
      els.heavyNote.style.display = 'block';
      els.status.textContent = 'Large job detected. Click "Render Now" to proceed.';
    }else{
      els.btnRenderNow.style.display = 'none';
      els.heavyNote.style.display = 'none';
      renderTimeout = setTimeout(()=>renderSpectrogram(), 300);
    }
  }
  
  // Manual render button
  if(els.btnRenderNow){
    els.btnRenderNow.addEventListener('click', ()=>{
      renderSpectrogram();
    });
  }
  
  // Auto-schedule on parameter changes
  ['fftSize','dynRange','scale','minHz','maxHz','pxH','pxPerSec'].forEach(id=>{
    if(els[id]){
      els[id].addEventListener('change', ()=>{
        if(audioBuffer) scheduleRender();
      });
    }
  });
  
  /* ============================================
     SPECTROGRAM RENDERING
     ============================================ */
  function renderSpectrogram(){
    if(!audioBuffer) return;
    
    els.status.textContent = 'Rendering...';
    els.btnDownload.disabled = true;
    
    // Get parameters
    const fftSize = Number(els.fftSize.value);
    const hop = Math.round(fftSize/2);
    const dynRange = Number(els.dynRange.value);
    const scaleType = els.scale.value;
    const nyquist = meta.sampleRate/2;
    const isLog = (scaleType === 'log');
    const isMel = (scaleType === 'mel');
    const isBark = (scaleType === 'bark');
    const minHz = Number(els.minHz.value);
    const maxHz = Number(els.maxHz.value);
    const effMinHz = (isLog || isMel || isBark) ? Math.max(1, minHz) : minHz;
    const effMaxHz = maxHz>0 ? Math.min(maxHz, nyquist) : nyquist;
    const pxH = Number(els.pxH.value);
    const pxPerSec = Number(els.pxPerSec.value);
    
    
    // Mix to mono
    const mono = new Float32Array(audioBuffer.length);
    for(let ch=0; ch<audioBuffer.numberOfChannels; ch++){
      const chData = audioBuffer.getChannelData(ch);
      for(let i=0; i<mono.length; i++){
        mono[i] += chData[i];
      }
    }
    for(let i=0; i<mono.length; i++){
      mono[i] /= audioBuffer.numberOfChannels;
    }
    
    // Compute STFT
    const window = hann(fftSize);
    const frames = Math.floor((mono.length - fftSize)/hop)+1;
    const bins = fftSize/2+1;
    
    const mag = new Float32Array(frames*bins);
    const re = new Float32Array(fftSize);
    const im = new Float32Array(fftSize);
    
    for(let f=0; f<frames; f++){
      const offset = f*hop;
      for(let i=0; i<fftSize; i++){
        re[i] = (offset+i < mono.length) ? mono[offset+i]*window[i] : 0;
        im[i] = 0;
      }
      FFT(fftSize, re, im);
      for(let b=0; b<bins; b++){
        mag[f*bins+b] = Math.sqrt(re[b]*re[b] + im[b]*im[b]);
      }
    }
    
    // Find global max
    let globalMax = 0;
    for(let i=0; i<mag.length; i++){
      if(mag[i]>globalMax) globalMax = mag[i];
    }
    if(globalMax<1e-12) globalMax=1e-12;
    
    // Convert to dB
    const magDB = new Float32Array(mag.length);
    for(let i=0; i<mag.length; i++){
      magDB[i] = 20*Math.log10((mag[i]/globalMax)+1e-12);
    }
    
    function freqToY(hz){
      if(isLog){
        const logMin = Math.log(effMinHz);
        const logMax = Math.log(effMaxHz);
        const logHz = Math.log(Math.max(hz, effMinHz));
        return pxH - 1 - Math.round((logHz-logMin)/(logMax-logMin)*(pxH-1));
      }else if(isMel){
        const melMin = hzToMel(effMinHz);
        const melMax = hzToMel(effMaxHz);
        const melHz = hzToMel(Math.max(hz, effMinHz));
        return pxH - 1 - Math.round((melHz-melMin)/(melMax-melMin)*(pxH-1));
      }else if(isBark){
        const barkMin = hzToBark(effMinHz);
        const barkMax = hzToBark(effMaxHz);
        const barkHz = hzToBark(Math.max(hz, effMinHz));
        return pxH - 1 - Math.round((barkHz-barkMin)/(barkMax-barkMin)*(pxH-1));
      }else{
        return pxH - 1 - Math.round((hz-effMinHz)/(effMaxHz-effMinHz)*(pxH-1));
      }
    }
    
    // Resample to image dimensions
    const w = Math.ceil(meta.duration * pxPerSec);
    const h = pxH;
    const gray8 = new Uint8ClampedArray(w*h);
    
    // Resample columns
    for(let x=0; x<w; x++){
      const t = (x/w)*meta.duration;
      const frameIdx = Math.min(Math.floor(t/(hop/meta.sampleRate)), frames-1);
      
      for(let y=0; y<h; y++){
        // Map y to frequency
        let hz;
        if(isLog){
          const logMin = Math.log(effMinHz);
          const logMax = Math.log(effMaxHz);
          const frac = (h-1-y)/(h-1);
          hz = Math.exp(logMin + frac*(logMax-logMin));
        }else if(isMel){
          const melMin = hzToMel(effMinHz);
          const melMax = hzToMel(effMaxHz);
          const frac = (h-1-y)/(h-1);
          const mel = melMin + frac*(melMax-melMin);
          hz = melToHz(mel);
        }else if(isBark){
          const barkMin = hzToBark(effMinHz);
          const barkMax = hzToBark(effMaxHz);
          const frac = (h-1-y)/(h-1);
          const bark = barkMin + frac*(barkMax-barkMin);
          hz = barkToHz(bark);
        }else{
          hz = effMinHz + (h-1-y)/(h-1)*(effMaxHz-effMinHz);
        }
        const binFloat = (hz/nyquist)*(bins-1);
        const binIdx = Math.min(Math.max(Math.floor(binFloat), 0), bins-1);
        
        const db = magDB[frameIdx*bins + binIdx];
        const norm = Math.max(0, Math.min(1, (db+dynRange)/dynRange));
        
        gray8[y*w+x] = Math.round(norm*255);
      }
    }
    
    // Store offscreen data
    offscreen = { w, h, gray8 };
    
    // Render to canvas
    renderOffscreenToCanvas();
    
    // Enable download
    els.btnDownload.disabled = false;
    els.status.textContent = `Rendered: ${w}x${h} px`;
  }
  
  /* ============================================
     RENDER OFFSCREEN TO CANVAS
     ============================================ */
  function renderOffscreenToCanvas(){
    if(!offscreen || !offscreen.gray8) return;
    
    const w = offscreen.w;
    const h = offscreen.h;
    
    // Apply colormap
    const rgba = new Uint8ClampedArray(w*h*4);
    const invertNow = !(invertChk && invertChk.checked);
    
    for(let i=0; i<w*h; i++){
      const val = offscreen.gray8[i];
      const v = invertNow ? (255-val) : val;
      const lutIdx = v*4;
      rgba[i*4] = LUT[lutIdx];
      rgba[i*4+1] = LUT[lutIdx+1];
      rgba[i*4+2] = LUT[lutIdx+2];
      rgba[i*4+3] = 255;
    }
    
    // Update canvas
    els.cSpec.width = w;
    els.cSpec.height = h;
    els.cSpec.style.position = 'absolute';
    els.cSpec.style.left = '0px';
    els.cSpec.style.top = '0px';
    els.cSpec.style.zIndex = '3';
    
    const ctx = els.cSpec.getContext('2d', {willReadFrequently: true});
    ctx.imageSmoothingEnabled = false;
    ctx.putImageData(new ImageData(rgba, w, h), 0, 0);
    
    offscreen.imageData = new ImageData(rgba, w, h);
  }
  
  /* ============================================
     INTERACTION HANDLERS
     ============================================ */
  
  
  // Mouse wheel behavior: scroll normally, shift=horizontal scroll, ctrl=zoom both
  if (els.specWrap) {
    els.specWrap.addEventListener('wheel', (e) => {
      if (!offscreen) return;
  
      // Ctrl + wheel => zoom centered on mouse position
      if (e.ctrlKey) {
        e.preventDefault();
      
        const rect = els.cSpec.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
      
        const fracX = mouseX / els.cSpec.width;
        const fracY = mouseY / els.cSpec.height;
      
        const delta = Math.sign(e.deltaY) * 0.1;
      
        const oldZoomX = zoomX;
        const oldZoomY = zoomY;
      
        zoomX = Math.max(0.25, Math.min(16, zoomX * (1 - delta)));
        zoomY = Math.max(0.25, Math.min(8, zoomY * (1 - delta)));
      
        applyZoom();
      
        const newW = els.cSpec.width;
        const newH = els.cSpec.height;
      
        // Adjust scroll so the mouse focus point stays fixed
        els.specWrap.scrollLeft =
          els.specWrap.scrollLeft +
          (newW * fracX - mouseX) -
          (els.cSpec.width / oldZoomX * fracX - mouseX);
      
        els.specWrap.scrollTop =
          els.specWrap.scrollTop +
          (newH * fracY - mouseY) -
          (els.cSpec.height / oldZoomY * fracY - mouseY);
      
        return;
      }
  
      // Shift + wheel => horizontal scroll
      if (e.shiftKey && !e.ctrlKey) {
        e.preventDefault();
        els.specWrap.scrollLeft += e.deltaY; 
        return;
      }
  
      // Wheel alone => normal up/down scrolling
      // Let browser handle it: do NOT preventDefault()
    }, { passive: false });
  }

  // Apply zoom to canvas
  function applyZoom(){
    if(!offscreen) return;
    const baseW = offscreen.w;
    const baseH = offscreen.h;
    const newW = Math.max(200, Math.round(baseW * zoomX));
    const newH = Math.max(200, Math.round(baseH * zoomY));
    els.cSpec.width = newW;
    els.cSpec.height = newH;
    
    // Redraw with zoom
    const ctx = els.cSpec.getContext('2d', {willReadFrequently: true});
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0, 0, newW, newH);
    if(offscreen.imageData){
      // Create temporary canvas with original data
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = offscreen.w;
      tempCanvas.height = offscreen.h;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.putImageData(offscreen.imageData, 0, 0);
      
      // Draw scaled
      ctx.drawImage(tempCanvas, 0, 0, newW, newH);
    }
    
  }
  
  // Pan dragging
  let drag=false, sx=0, sy=0, scrollL=0, scrollT=0;
  if(els.specWrap){
    els.specWrap.addEventListener('mousedown', (e)=>{
      drag=true;
      sx=e.clientX;
      sy=e.clientY;
      scrollL=els.specWrap.scrollLeft;
      scrollT=els.specWrap.scrollTop;
    });
  }
  window.addEventListener('mouseup', ()=> drag=false);
  window.addEventListener('mousemove', (e)=>{
    if(!drag || !els.specWrap) return;
    els.specWrap.scrollLeft = scrollL - (e.clientX - sx);
    els.specWrap.scrollTop = scrollT - (e.clientY - sy);
  });
  
  // Cursor position display
  if(els.cSpec){
    els.cSpec.addEventListener('mousemove', (e)=>{
      if(!offscreen) return;
      
      const rect = els.cSpec.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      const t = (x/els.cSpec.width)*meta.duration;
      
      const scaleType = els.scale.value;
      const isLog = (scaleType === 'log');
      const isMel = (scaleType === 'mel');
      const isBark = (scaleType === 'bark');
      const minHz = Number(els.minHz.value);
      const maxHz = Number(els.maxHz.value) || (meta.sampleRate/2);
      const effMinHz = (isLog || isMel || isBark) ? Math.max(1, minHz) : minHz;
      const h = els.cSpec.height;
      
      let hz;
      if(isLog){
        const logMin = Math.log(effMinHz);
        const logMax = Math.log(maxHz);
        const frac = (h-1-y)/(h-1);
        hz = Math.exp(logMin + frac*(logMax-logMin));
      }else if(isMel){
        const melMin = hzToMel(effMinHz);
        const melMax = hzToMel(maxHz);
        const frac = (h-1-y)/(h-1);
        const mel = melMin + frac*(melMax-melMin);
        hz = melToHz(mel);
      }else if(isBark){
        const barkMin = hzToBark(effMinHz);
        const barkMax = hzToBark(maxHz);
        const frac = (h-1-y)/(h-1);
        const bark = barkMin + frac*(barkMax-barkMin);
        hz = barkToHz(bark);
      }else{
        hz = effMinHz + (h-1-y)/(h-1)*(maxHz-effMinHz);
      }
      els.cursor.textContent = `${fmtTime(t)} • ${Math.round(hz)} Hz`;
    });
  }
  
  // Double-click to reset zoom
  if(els.specWrap){
    els.specWrap.addEventListener('dblclick', ()=>{
      zoomX=1;
      zoomY=1;
      if(offscreen){
        els.cSpec.width = offscreen.w;
        els.cSpec.height = offscreen.h;
        renderOffscreenToCanvas();
      }
    });
  }
  
  /* ============================================
     PNG EXPORT FUNCTIONS
     ============================================ */
  
  function _concat(chunks){
    let len=0;
    for(const c of chunks) len+=c.length;
    const out=new Uint8Array(len);
    let pos=0;
    for(const c of chunks){
      out.set(c, pos);
      pos+=c.length;
    }
    return out;
  }
  
  function _crc32(buf){
    const table=new Uint32Array(256);
    for(let i=0;i<256;i++){
      let c=i;
      for(let k=0;k<8;k++) c=(c&1)?(0xedb88320^(c>>>1)):(c>>>1);
      table[i]=c;
    }
    let crc=0xffffffff;
    for(let i=0;i<buf.length;i++){
      crc=table[(crc^buf[i])&0xff]^(crc>>>8);
    }
    return (crc^0xffffffff)>>>0;
  }
  
  function _chunk(type,data){
    const len=data?data.length:0;
    const buf=new Uint8Array(4+4+len+4);
    const dv=new DataView(buf.buffer);
    dv.setUint32(0,len);
    buf.set(type,4);
    if(data) buf.set(data,8);
    const crcData=new Uint8Array(buf.buffer,4,4+len);
    dv.setUint32(8+len,_crc32(crcData));
    return buf;
  }
  
  function _zlibStore(data){
    const bsize=65535;
    const blocks=[];
    let i=0;
    while(i<data.length){
      const chunk=data.subarray(i, Math.min(i+bsize, data.length));
      const isLast=(i+chunk.length>=data.length)?1:0;
      const hdr=new Uint8Array(5);
      hdr[0]=(isLast<<0)|(0<<1);
      hdr[1]=chunk.length&0xff;
      hdr[2]=(chunk.length>>>8)&0xff;
      hdr[3]=(~chunk.length)&0xff;
      hdr[4]=((~chunk.length)>>>8)&0xff;
      blocks.push(hdr,chunk);
      i+=chunk.length;
    }
    const adler=_adler32(data);
    const header=new Uint8Array([0x78,0x01]);
    const footer=new Uint8Array(4);
    new DataView(footer.buffer).setUint32(0,adler);
    return _concat([header,...blocks,footer]);
  }
  
  function _adler32(data){
    let a=1,b=0;
    for(let i=0;i<data.length;i++){
      a=(a+data[i])%65521;
      b=(b+a)%65521;
    }
    return (b<<16)|a;
  }
  
  function encodeRGBA8(w, h, rgba, meta){
    const sig = new Uint8Array([137,80,78,71,13,10,26,10]);
  
    const ihdr = new Uint8Array(13);
    const dv = new DataView(ihdr.buffer);
    dv.setUint32(0,w);
    dv.setUint32(4,h);
    ihdr[8] = 8;  // 8-bit
    ihdr[9] = 6;  // color RGBA
    ihdr[10]=0;
    ihdr[11]=0;
    ihdr[12]=0;
  
    const chunks = [
      sig,
      _chunk(new Uint8Array([73,72,68,82]), ihdr)
    ];
  
    if(meta){
      for(const k in meta){
        const text = new TextEncoder().encode(k + "\x00" + meta[k]);
        chunks.push(_chunk(new Uint8Array([116,69,88,116]), text)); // tEXt
      }
    }
  
    // Each row: filter byte then RGBA data
    const scan = new Uint8Array(h * (1 + w*4));
    let si = 0, di = 0;
    for(let y = 0; y < h; y++){
      scan[di++] = 0;
      for(let x = 0; x < w*4; x++){
        scan[di++] = rgba[si++];
      }
    }
  
    const z = _zlibStore(scan);
    chunks.push(_chunk(new Uint8Array([73,68,65,84]), z)); // IDAT
    chunks.push(_chunk(new Uint8Array([73,69,78,68]), null)); // IEND
  
    return _concat(chunks);
  }

  // Export button handler
  if(els.btnDownload){
    els.btnDownload.addEventListener('click', ()=>{
      if(!offscreen) return;
      const w = offscreen.w, h = offscreen.h;
      
      // ? 8-bit grayscale export with metadata
      if (!(w > 0 && h > 0)) return;
      
      const invNow = !(document.getElementById('invertColors')?.checked);
      
      // Build RGBA pixel buffer using the colormap LUT (matches preview)
      const rgba = new Uint8ClampedArray(offscreen.gray8.length * 4);
      for (let i = 0; i < offscreen.gray8.length; i++) {
        const v = offscreen.gray8[i];
        const lutIdx = (invNow ? (255 - v) : v) * 4;
        rgba[i*4+0] = LUT[lutIdx+0];
        rgba[i*4+1] = LUT[lutIdx+1];
        rgba[i*4+2] = LUT[lutIdx+2];
        rgba[i*4+3] = 255;
      }
      
      const metaOut = {
        colormap: String(els.colormap?.value || 'grayscale'),
        invertColors: String(!invNow),             // matches UI label now
        fftSize: String(Number(els.fftSize.value)||0),
        hop: String(Math.round((Number(els.fftSize.value)||0)/2)),
        sampleRate: String(meta?.sampleRate || 48000),
        dynRange: String(Number(els.dynRange.value)||0),
        scale: String(els.scale?.value || 'linear'),
        minHz: String(Number(els.minHz.value)||0),
        maxHz: String(Number(els.maxHz.value)||0),
        pxPerSec: String(Number(els.pxPerSec.value)||0),
        optimized: String(wasOptimized),
        duration_sec: String(meta?.duration?.toFixed(6)||'0')
      };
      
      const png = encodeRGBA8(w, h, rgba, metaOut);
      const blob = new Blob([png], {type:'image/png'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.download = 'spectrogram.png';
      a.href = url;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 2000);
      
      els.status.textContent = `Exported: PNG with metadata`;
    });
  }
  
  /* ============================================
     INITIALIZATION
     ============================================ */
  
  (function(){
    // Estimate proper initial canvas size so it is visible before zoom/interaction
    const width = Math.max(600, Math.ceil(20 * Number(els.pxPerSec.value)));
    const height = Math.max(300, Number(els.pxH.value));
    els.cSpec.width = width;
    els.cSpec.height = height;
    els.cSpec.style.position='absolute';
    els.cSpec.style.left = '0px';
    els.cSpec.style.top = '0px';
  })();
  </script>

  <!-- License Modal Handler Script -->
  <script>
    (function(){
      const licenseLink = document.getElementById('licenseLink');
      const licenseModal = document.getElementById('licenseModal');
      const licenseOverlay = document.getElementById('licenseOverlay');
      const licenseClose = document.getElementById('licenseClose');

      if(!licenseLink || !licenseModal || !licenseOverlay || !licenseClose) return;

      function showLicense() {
        licenseModal.classList.add('show');
        licenseOverlay.classList.add('show');
      }

      function hideLicense() {
        licenseModal.classList.remove('show');
        licenseOverlay.classList.remove('show');
      }

      licenseLink.addEventListener('click', showLicense);
      licenseClose.addEventListener('click', hideLicense);
      licenseOverlay.addEventListener('click', hideLicense);
    })();
  </script>
  <!-- Scale Warning Modal Handler Script -->
  <script>
    (function(){
      const scaleWarningModal = document.getElementById('scaleWarningModal');
      const scaleWarningOverlay = document.getElementById('scaleWarningOverlay');
      const scaleWarningClose = document.getElementById('scaleWarningClose');
  
      if(!scaleWarningModal || !scaleWarningOverlay || !scaleWarningClose) return;
  
      window.showScaleWarning = function() {
        scaleWarningModal.classList.add('show');
        scaleWarningOverlay.classList.add('show');
      };
  
      function hideScaleWarning() {
        scaleWarningModal.classList.remove('show');
        scaleWarningOverlay.classList.remove('show');
      }
  
      scaleWarningClose.addEventListener('click', hideScaleWarning);
      scaleWarningOverlay.addEventListener('click', hideScaleWarning);
    })();
  </script>
</body>
</html>
