<!DOCTYPE html>
<html lang="en">
<head>
  <!--
    MIT License
    
    Copyright (c) 2025 NQR
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
  -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SpectroGhost | NQR Labs</title>
  <meta name="description" content="High resolution, zoomable spectrogram creator. Runs fully in-browser.">

  <!-- Open Graph -->
  <meta property="og:title" content="SpectroGhost | NQR Labs">
  <meta property="og:description" content="High resolution, zoomable spectrogram creator. Runs fully in-browser.">
  <meta property="og:image" content="https://nqrlabs.com/SpectroGhost/assets/images/android-chrome-512x512.png">
  <meta property="og:url" content="https://nqrlabs.com/SpectroGhost/">
  <meta property="og:type" content="website">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="SpectroGhost | NQR Labs">
  <meta name="twitter:description" content="High resolution, zoomable spectrogram creator. Runs fully in-browser.">
  <meta name="twitter:image" content="https://nqrlabs.com/SpectroGhost/assets/images/android-chrome-512x512.png">

  <!-- Canonical URL -->
  <link rel="canonical" href="https://nqrlabs.com/SpectroGhost/">

  <!-- Favicon links -->
  <link rel="icon" type="image/png" sizes="16x16" href="assets/images/favicon-16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="assets/images/favicon-32x32.png">
  <link rel="apple-touch-icon" sizes="180x180" href="assets/images/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="assets/images/android-chrome-192x192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="assets/images/android-chrome-512x512.png">
  
  <style>
    /* ============================================
       CSS VARIABLES
       ============================================ */
    :root {
      --bg: #0c1020;
      --card: #151c3b;
      --ink: #eef1ff;
      --dim: #b9c6ef;
      --border: #2b3868;
      --accent: #1fc9aa;
      --accent-hover: #18b79a;
      --accent-dark: #17b399;
      --input-bg: #0f1432;
    }

    /* ============================================
       BASE STYLES
       ============================================ */
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      min-height: 100vh;
    }

    h2 {
      margin: 16px 0 8px;
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    h3 {
      margin: 0 0 12px 0;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.5px;
      color: var(--accent);
      text-transform: uppercase;
      text-align: left;
    }

    /* ============================================
       CONTROLS SECTION
       ============================================ */
    .controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 92vw;
      max-width: 760px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    .control-section {
      width: 100%;
      padding: 16px 0;
      border-bottom: 1px solid var(--border);
    }

    .control-section:last-of-type {
      border-bottom: none;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 16px;
      justify-content: center;
      align-items: flex-end;
    }

    /* ============================================
       FORM ELEMENTS
       ============================================ */
    label {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
      font-weight: bold;
      color: var(--dim);
      text-align: center;
      align-items: center;
      cursor: default;
    }

    label.clickable {
      cursor: pointer;
    }

    label.clickable:hover {
      color: var(--accent);
    }

    label.inline {
      flex-direction: row;
      align-items: center;
      gap: 8px;
    }

    input[type="number"],
    input[type="file"],
    select {
      background: var(--input-bg);
      border: 1px solid var(--border);
      color: var(--ink);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 14px;
      min-width: 100px;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    input[type="number"]:focus,
    input[type="file"]:focus,
    select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(31, 201, 170, 0.1);
    }

    input[type="file"] {
      cursor: pointer;
      padding: 8px 12px;
      width: auto;
      min-width: 300px;
    }

    /* Modern browsers (Chrome, Edge, Firefox, Safari 14+) */
    input[type="file"]::file-selector-button {
      background: var(--accent);
      color: #0b0f14;
      border: 1px solid var(--accent-dark);
      border-radius: 8px;
      padding: 10px 16px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.3px;
      transition: all 0.15s ease;
      box-shadow: 0 2px 4px rgba(31, 201, 170, 0.2);
      margin-right: 10px; /* space before filename text */
    }
    
    /* Hover/active to match your button styles */
    input[type="file"]::file-selector-button:hover {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(31, 201, 170, 0.3);
    }
    input[type="file"]::file-selector-button:active {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(31, 201, 170, 0.2);
    }
    
    /* Safari <14 (legacy WebKit fallback) */
    input[type="file"]::-webkit-file-upload-button {
      background: var(--accent);
      color: #0b0f14;
      border: 1px solid var(--accent-dark);
      border-radius: 8px;
      padding: 10px 16px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.3px;
      transition: all 0.15s ease;
      box-shadow: 0 2px 4px rgba(31, 201, 170, 0.2);
      margin-right: 10px;
    }
    input[type="file"]::-webkit-file-upload-button:hover {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(31, 201, 170, 0.3);
    }
    input[type="file"]::-webkit-file-upload-button:active {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(31, 201, 170, 0.2);
    }

    input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
      cursor: pointer;
      margin: 0;
    }

    /* Colormap Radio Button List */
    .colormap-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      width: 220px;
      margin: 0 auto;
    }

    .colormap-option {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      padding: 4px 6px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .colormap-option:hover {
      background: rgba(31, 201, 170, 0.1);
    }

    .colormap-option input[type="radio"] {
      cursor: pointer;
      accent-color: var(--accent);
      flex-shrink: 0;
      margin: 0;
    }

    .colormap-option input[type="radio"]:checked + .colormap-name {
      color: var(--accent);
      font-weight: 600;
    }

    .colormap-name {
      text-align: center;
      font-size: 13px;
      font-weight: 600;
      color: var(--ink);
      width: 65px;
      flex-shrink: 0;
    }

    .option-gradient {
      height: 8px;
      border-radius: 2px;
      width: 90px;
      flex-shrink: 0;
      border: 0px solid transparent;
    }

    .gradient-grayscale {
      background: linear-gradient(to right, #ffffff, #000000) !important;
    }
    
    .gradient-viridis {
      background: linear-gradient(to right, #440154, #3b528b, #21918c, #5ec962, #fde725) !important;
    }
    
    .gradient-plasma {
      background: linear-gradient(to right, #0d0887, #7e03a8, #cc4778, #f89540, #f0f921) !important;
    }
    
    .gradient-inferno {
      background: linear-gradient(to right, #000004, #420a68, #932667, #dd513a, #fca50a, #fcffa4) !important;
    }
    
    .gradient-magma {
      background: linear-gradient(to right, #000004, #3b0f70, #8c2981, #de4968, #fe9f6d, #fcfdbf) !important;
    }
    
    .gradient-jet {
      background: linear-gradient(to right, #00007f, #0000ff, #00ffff, #00ff00, #ffff00, #ff0000, #7f0000) !important;
    }
    
    .gradient-hot {
      background: linear-gradient(to right, #000000, #ff0000, #ffff00, #ffffff) !important;
    }
    
    .gradient-cool {
      background: linear-gradient(to right, #00ffff, #ff00ff) !important;
    }
    
    .gradient-parula {
      background: linear-gradient(to right, #352a87, #0f5cdd, #00a6ff, #ffed00, #ff4d00) !important;
    }

    .gradient-roseus {
      background: linear-gradient(to right, #010101, #06234f, #7e17a2, #d93a6f, #f6ba6b, #fffbf9) !important;
    }

    /* ============================================
       BUTTONS
       ============================================ */
    button {
      background: var(--accent);
      color: #0b0f14;
      border: 1px solid var(--accent-dark);
      border-radius: 8px;
      padding: 10px 16px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.3px;
      transition: all 0.15s ease;
      box-shadow: 0 2px 4px rgba(31, 201, 170, 0.2);
    }

    button:hover:not(:disabled) {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(31, 201, 170, 0.3);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(31, 201, 170, 0.2);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    button.recording {
      background: #ff4444;
      border-color: #cc3333;
      animation: rec-pulse 1s ease-in-out infinite;
    }
    button.recording:hover:not(:disabled) {
      background: #ee3333;
      border-color: #cc3333;
    }
    @keyframes rec-pulse {
      0%, 100% { box-shadow: 0 2px 4px rgba(255, 68, 68, 0.3); }
      50% { box-shadow: 0 2px 12px rgba(255, 68, 68, 0.6); }
    }

    /* ============================================
       SPECTROGRAM DISPLAY
       ============================================ */
    .spec-container {
      width: 92vw;
      max-width: 1400px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      margin: 0 0 20px 0;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    .spec-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    .spec-title {
      font-size: 15px;
      font-weight: 600;
      color: var(--ink);
    }

    .spec-info {
      font-size: 13px;
      color: var(--dim);
      font-variant-numeric: tabular-nums;
    }

    .spec-wrap {
      position: relative;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #0f1432;
      height: 520px;
      cursor: grab;
    }

    .spec-wrap:active {
      cursor: grabbing;
    }

    .spec-inner {
      position: relative;
      height: 100%;
    }

    canvas {
      image-rendering: pixelated;
    }

    /* ============================================
       STATUS & INFO
       ============================================ */
    .status-bar {
      font-size: 13px;
      color: var(--dim);
    }

    .help-text {
      font-size: 12px;
      color: var(--dim);
      margin-top: 12px;
      line-height: 1.5;
    }

    /* ============================================
       LICENSE FOOTER
       ============================================ */
    .license-footer {
      width: 100%;
      max-width: 760px;
      border-top: 2px solid #3b528b;
      margin-top: auto;
      margin-bottom: 0px;
      padding: 10px 0px;
      font-size: 0.68rem;
      color: #a9a9b2;
      opacity: 0.7;
      transition: opacity 0.3s ease;
      text-align: center;
      text-decoration: none;
    }
    
    .license-footer a {
      color: #a9a9b2;
      text-decoration: none;
      cursor: pointer;
    }
    
    .license-footer a:hover { 
      color: #97f3d2;
      cursor: pointer;
      opacity: 1;
      text-decoration: underline;
    }

    .license-modal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--card);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0,0,0,.6);
      z-index: 1000;
      text-align: left;
    }

    .license-modal.show {
      display: block;
    }

    .license-modal h3 {
      margin-top: 0;
      color: var(--ink);
      text-align: center;
      text-transform: none;
    }

    .license-modal pre {
      white-space: pre-wrap;
      font-size: 11px;
      line-height: 1.5;
      color: var(--dim);
      text-align: left;
    }

    .license-modal-close {
      float: right;
      cursor: pointer;
      font-size: 24px;
      color: var(--dim);
      transition: color 0.2s ease;
    }

    .license-modal-close:hover {
      color: var(--ink);
    }

    .license-overlay {
      display: none;
      backdrop-filter: blur(4px);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 999;
    }

    .license-overlay.show {
      display: block;
    }

    /* ============================================
       RESPONSIVE DESIGN
       ============================================ */
    @media (max-width: 640px) {
      .controls, .spec-container {
        padding: 16px 12px;
        width: 95vw;
      }

      .row {
        gap: 8px 12px;
      }

      .control-section .row > label {
        align-items: center;  /* centers the input under the text */
        text-align: center;   /* centers the label text iteself */
      }

      label {
        font-size: 12px;
        font-weight: 600;
      }

      input[type="number"],
      select {
        font-size: 13px;
        padding: 5px 7px;
        min-width: 80px;
      }

      input[type="file"] {
        margin: 8px;
        padding: 8px 12px;
        background: var(--input-bg);
        border: 1px solid var(--border);
        border-radius: 8px;
        color: var(--ink);
        cursor: pointer;
        min-width: 200px;
        font-size: 14px;
      }

      button {
        padding: 8px 14px;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <img src="assets/images/logo.png" alt="SpectroGhost Logo" style="max-width: 200px; height: auto; margin: 20px 0 10px;">
  <h2>SpectroGhost</h2>
  <p style="color: var(--dim); font-size: 14px; margin: -5px 0 15px; font-style: italic;">A lightweight spectrogram creator by NQR</p>
  
  <!-- Controls -->
  <div class="controls">
    <!-- File Input -->
    <div class="control-section">
      <h3>üéµ Audio Input</h3>
      <div class="row" style="align-items: center; gap: 10px; flex-wrap: wrap;">
        <input type="file" id="fileIn" accept="audio/*">
        <button id="btnRecord" type="button">‚è∫ Record</button>
        <span id="recTimer" style="display:none; font-variant-numeric: tabular-nums; color: #ff6666;">0:00</span>
        <button id="btnSaveRecording" type="button" style="display:none;">üíæ Save Recording</button>
      </div>
    </div>

    <!-- Basic Settings (combined with frequency range and advanced) -->
    <div class="control-section">
      <h3>‚öôÔ∏è Basic Settings</h3>
      <div class="row">
        <label>Duration
          <input type="text" id="diagDuration" value="‚Äî" readonly style="width: 90px; opacity: 0.7; cursor: default;">
        </label>
        <label>Sample Rate
          <input type="text" id="diagSampleRate" value="‚Äî" readonly style="width: 90px; opacity: 0.7; cursor: default;">
        </label>
        <label>FFT Size
          <select id="fftSize">
            <option>256</option>
            <option>512</option>
            <option>1024</option>
            <option selected>2048</option>
            <option>4096</option>
            <option>8192</option>
            <option>16384</option>
          </select>
        </label>
        
        <label>Dynamic Range (dB)
          <input type="number" id="dynRange" value="80" min="20" max="140" step="1">
        </label>
        
        <label>Scale
          <select id="scale">
            <option value="linear" selected>Linear</option>
            <option value="log">Log</option>
            <option value="mel">Mel</option>
            <option value="bark">Bark</option>
          </select>
        </label>
      </div>
      <div class="row">
        <label>Min Frequency (Hz)
          <input type="number" id="minHz" value="0" min="0" step="1">
        </label>
        
        <label>Max Frequency (Hz)
          <input type="number" id="maxHz" value="0" min="0" step="1">
        </label>
        
      </div>
    </div>

    <!-- Display Settings (with colormap) -->
    <div class="control-section">
      <h3>üñºÔ∏è Display Settings</h3>
      <div class="row">
        <label class="clickable" id="pxHLabel" title="Double-click to set ideal value">Height (px)
          <input type="number" id="pxH" value="480" min="200" max="4000" step="10">
        </label>
        
        <label class="clickable" id="pxPerSecLabel" title="Double-click to set ideal value">Pixels / Second
          <input type="number" id="pxPerSec" value="300" min="50" max="4000" step="10">
        </label>

        <label>Overlap %
          <select id="overlapPercent">
            <option value="50">50% (min)</option>
            <option value="75" selected>75% (recommended)</option>
            <option value="87.5">87.5% (max)</option>
          </select>
        </label>

        <label>Window
          <select id="windowFunction">
            <option value="hann" selected>Hann</option>
            <option value="hamming">Hamming</option>
            <option value="blackman">Blackman</option>
            <option value="rectangular">Rectangular</option>
          </select>
        </label>

        <button id="btnMakeInvertible">Optimize</button>
      </div>
      
      <div class="row" style="margin-top: 12px;">
        <div style="display: flex; flex-direction: column; align-items: center; gap: 12px;">
          <div style="font-size: 13px; font-weight: bold; color: var(--dim);">Colormap</div>
          <div class="colormap-list">
            <label class="colormap-option">
              <input type="radio" name="colormap" value="grayscale" checked>
              <span class="colormap-name">Grayscale</span>
              <div class="option-gradient gradient-grayscale"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="viridis">
              <span class="colormap-name">Viridis</span>
              <div class="option-gradient gradient-viridis"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="plasma">
              <span class="colormap-name">Plasma</span>
              <div class="option-gradient gradient-plasma"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="inferno">
              <span class="colormap-name">Inferno</span>
              <div class="option-gradient gradient-inferno"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="magma">
              <span class="colormap-name">Magma</span>
              <div class="option-gradient gradient-magma"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="jet">
              <span class="colormap-name">Jet</span>
              <div class="option-gradient gradient-jet"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="hot">
              <span class="colormap-name">Hot</span>
              <div class="option-gradient gradient-hot"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="cool">
              <span class="colormap-name">Cool</span>
              <div class="option-gradient gradient-cool"></div>
            </label>
            
            <label class="colormap-option">
              <input type="radio" name="colormap" value="parula">
              <span class="colormap-name">Parula</span>
              <div class="option-gradient gradient-parula"></div>
            </label>

            <label class="colormap-option">
              <input type="radio" name="colormap" value="roseus">
              <span class="colormap-name">Roseus</span>
              <div class="option-gradient gradient-roseus"></div>
            </label>
          </div>
          
          <label class="clickable inline">
            <input type="checkbox" id="invertColors">
            Invert Colors
          </label>
          <label class="clickable inline">
            <input type="checkbox" id="srgbGamma">
            sRGB Gamma Encoding
          </label>
        </div>
        
        <!-- Hidden select for compatibility -->
        <select id="colormap" style="display: none;">
          <option value="grayscale">Grayscale</option>
          <option value="viridis">Viridis</option>
          <option value="plasma">Plasma</option>
          <option value="inferno">Inferno</option>
          <option value="magma">Magma</option>
          <option value="jet">Jet</option>
          <option value="hot">Hot</option>
          <option value="cool">Cool</option>
          <option value="parula">Parula</option>
          <option value="roseus">Roseus</option>
        </select>
      </div>
    </div>

    <!-- Export Options -->
    <div class="control-section">
      <div class="row" style="gap: 16px;">
        <label class="clickable inline">
          <input type="checkbox" id="printBorder" checked>
          Border
        </label>
        <label class="clickable inline">
          <input type="checkbox" id="printInfo" checked>
          Info Margin
        </label>
      </div>
    </div>

    <!-- Action Buttons -->
    <div class="control-section">
      <div class="row" style="gap: 12px;">
        <button id="btnRenderNow" style="display:none;">Render Now</button>
        <button id="btnDownload" disabled>Export PNG</button>
        <button id="btnCopyClipboard" disabled>üìã Copy to Clipboard</button>
      </div>
      <div id="heavyNote" style="display:none; margin-top: 12px;">
        <small style="color: #f89540;">‚ö†Ô∏è Auto-render disabled for large job. Use "Render Now" or lower resolution.</small>
      </div>
      <div class="help-text">
        üí° <strong>Tip:</strong> Ctrl + Mouse wheel = zoom ‚Ä¢ Drag to pan ‚Ä¢ Double-click to reset ‚Ä¢ Ctrl+Shift+C = copy to clipboard
      </div>
    </div>
  </div>

  <!-- Spectrogram Display -->
  <div class="spec-container">
    <div class="spec-header">
      <div class="spec-title">üìà Spectrogram</div>
      <div class="status-bar" id="status">Ready ‚Ä¢ Load an audio file to begin</div>
      <div class="spec-info" id="cursor">00:00.000 ‚Ä¢ 0 Hz</div>
    </div>
    <div class="spec-wrap" id="specWrap">
      <div class="spec-inner" id="specInner">
        <canvas id="specCanvas"></canvas>
      </div>
    </div>
  </div>

  <!-- License Footer -->
  <div style="width:100%; max-width:760px; display: flex; justify-content: center;">
    <div class="license-footer">
      <a href="https://youtube.com/@CLU-NQR" target="_blank">YouTube</a> &middot;
      <a href="https://discord.gg/HT9YE8rvuN" target="_blank">Discord</a> &middot;
      <a href="https://nqrlabs.com" target="_blank">NQR Labs</a> &middot;
      <a href="https://github.com/NQRLabs" target="_blank">GitHub</a>
      <br>
      &copy; 2025 NQR &middot; <a id="licenseLink">License</a>
    </div>
  </div>

  <!-- License Modal -->
  <div class="license-overlay" id="licenseOverlay"></div>
  <div class="license-modal" id="licenseModal">
    <span class="license-modal-close" id="licenseClose">&times;</span>
    <h3>SpectroGhost License</h3>
    <pre>
SpectroGhost - MIT License

Copyright &copy; 2025 NQR

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</pre>
  </div>

  <script>
  "use strict";
  
  /* ============================================
     COLORMAP RADIO BUTTON HANDLER
     ============================================ */
  (function initColormapRadios() {
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initRadios);
    } else {
      initRadios();
    }
    
    function initRadios() {
      const radios = document.querySelectorAll('input[name="colormap"]');
      const hiddenSelect = document.getElementById('colormap');
      
      if(!hiddenSelect) return;
      
      radios.forEach(radio => {
        radio.addEventListener('change', (e) => {
          if (e.target.checked) {
            // Update hidden select to maintain existing functionality
            hiddenSelect.value = e.target.value;
            
            // Trigger change event on the hidden select
            const event = new Event('change', { bubbles: true });
            hiddenSelect.dispatchEvent(event);
          }
        });
      });
      
      // Initialize: sync hidden select value with checked radio
      const checkedRadio = document.querySelector('input[name="colormap"]:checked');
      if(checkedRadio) {
        hiddenSelect.value = checkedRadio.value;
      }
    }
  })();
  
  /* ============================================
     UTILITY FUNCTIONS
     ============================================ */
  
  /**
   * Format seconds as MM:SS.mmm
   * @param {number} s - Time in seconds
   * @returns {string} Formatted time string
   */
  const fmtTime = s => {
    const ms = Math.round((s%1)*1000).toString().padStart(3,'0');
    const m = Math.floor(s/60);
    const sec = Math.floor(s%60).toString().padStart(2,'0');
    return `${m}:${sec}.${ms}`;
  };
  
  /**
   * Generate Hann window for FFT analysis
   * @param {number} N - Window length
   * @returns {Float32Array} Hann window coefficients
   */
  function hann(N){
    const w = new Float32Array(N);
    for(let n=0; n<N; n++){
      w[n] = 0.5 * (1 - Math.cos(2*Math.PI*n/(N-1)));
    }
    return w;
  }

  /**
   * Generate Hamming window for FFT analysis
   * @param {number} N - Window length
   * @returns {Float32Array} Hamming window coefficients
   */
  function hamming(N){
    const w = new Float32Array(N);
    for(let n=0; n<N; n++){
      w[n] = 0.54 - 0.46 * Math.cos(2*Math.PI*n/(N-1));
    }
    return w;
  }

  /**
   * Generate Rectangular window (no windowing)
   * Provides narrowest main lobe (1 bin) but highest sidelobes (-13dB)
   * Best for pure tones where you want single-pixel spectral lines
   * @param {number} N - Window length
   * @returns {Float32Array} Rectangular window coefficients (all 1s)
   */
  function rectangular(N){
    const w = new Float32Array(N);
    for(let n=0; n<N; n++){
      w[n] = 1.0;
    }
    return w;
  }

  /**
   * Generate Blackman window
   * Wider main lobe (~6 bins) but excellent sidelobe suppression (-58dB)
   * Very clean for tonal analysis with minimal spectral leakage
   * @param {number} N - Window length
   * @returns {Float32Array} Blackman window coefficients
   */
  function blackman(N){
    const w = new Float32Array(N);
    for(let n=0; n<N; n++){
      w[n] = 0.42 - 0.5 * Math.cos(2*Math.PI*n/(N-1)) + 0.08 * Math.cos(4*Math.PI*n/(N-1));
    }
    return w;
  }

  /**
   * Convert Hz to Mel scale
   */
  function hzToMel(hz){
    return 2595 * Math.log10(1 + hz / 700);
  }
  
  /**
   * Convert Mel to Hz
   */
  function melToHz(mel){
    return 700 * (Math.pow(10, mel / 2595) - 1);
  }
  
  /**
   * Convert Hz to Bark scale
   */
  function hzToBark(hz){
    return 13 * Math.atan(0.00076 * hz) + 3.5 * Math.atan(Math.pow(hz / 7500, 2));
  }
  
  /**
   * Convert Bark to Hz
   */
  function barkToHz(bark){
    return 600 * Math.sinh(bark / 6);
  }
  
  /**
   * In-place radix-2 Cooley-Tukey FFT
   * @param {number} N - FFT size (must be power of 2)
   * @param {Float32Array} re - Real components (modified in-place)
   * @param {Float32Array} im - Imaginary components (modified in-place)
   */
  function FFT(N, re, im){
    // Bit-reversal permutation
    let i=0, j=0;
    for(i=0; i<N; i++){
      if(j>i){
        [re[i],re[j]] = [re[j],re[i]];
        [im[i],im[j]] = [im[j],im[i]];
      }
      let m = N>>1;
      while(m>=1 && j>=m){
        j -= m;
        m >>= 1;
      }
      j += m;
    }
    
    // FFT computation
    for(let len=2; len<=N; len<<=1){
      const ang = -2*Math.PI/len;
      const wlenr = Math.cos(ang);
      const wleni = Math.sin(ang);
      for(let i=0; i<N; i+=len){
        let wr=1, wi=0;
        for(let k=0; k<len/2; k++){
          const u_r = re[i+k];
          const u_i = im[i+k];
          const v_r = re[i+k+len/2]*wr - im[i+k+len/2]*wi;
          const v_i = re[i+k+len/2]*wi + im[i+k+len/2]*wr;
          re[i+k] = u_r + v_r;
          im[i+k] = u_i + v_i;
          re[i+k+len/2] = u_r - v_r;
          im[i+k+len/2] = u_i - v_i;
          const nwr = wr*wlenr - wi*wleni;
          wi = wr*wleni + wi*wlenr;
          wr = nwr;
        }
      }
    }
  }
  
  /* ============================================
     COLORMAPS (256-entry LUTs)
     ============================================ */
  
  // Global LUT array (RGBA, 256 entries)
  let LUT = new Uint8ClampedArray(256*4);
  
  // Grayscale (default)
  function buildGray(){
    for(let i=0; i<256; i++){
      LUT[i*4]=i; LUT[i*4+1]=i; LUT[i*4+2]=i; LUT[i*4+3]=255;
    }
  }
  
  // Helper: linear interpolate between colors
  function lerpColor(c0, c1, t){
    const r = Math.round(c0[0]+(c1[0]-c0[0])*t);
    const g = Math.round(c0[1]+(c1[1]-c0[1])*t);
    const b = Math.round(c0[2]+(c1[2]-c0[2])*t);
    return [r,g,b];
  }
  
  // Build gradient from key colors
  function buildGradient(colors){
    const n = colors.length-1;
    for(let i=0; i<256; i++){
      const t = 1 - (i / 255);
      const s = t*n;
      const idx = Math.min(Math.floor(s), n-1);
      const frac = s - idx;
      const c = lerpColor(colors[idx], colors[idx+1], frac);
      LUT[i*4]=c[0]; LUT[i*4+1]=c[1]; LUT[i*4+2]=c[2]; LUT[i*4+3]=255;
    }
  }

  // Build colormap from exact 256-entry normalized RGB data (0-1 range)
  function buildFromData(data){
    for(let i=0; i<256; i++){
      const idx = 255 - i; // Invert to match gradient direction (dark=low, bright=high)
      const rgb = data[idx];
      LUT[i*4]   = Math.round(rgb[0] * 255);
      LUT[i*4+1] = Math.round(rgb[1] * 255);
      LUT[i*4+2] = Math.round(rgb[2] * 255);
      LUT[i*4+3] = 255;
    }
  }

  // Roseus colormap data (perceptually uniform, from https://github.com/dofuuz/roseus)
  const ROSEUS_DATA = [
    [0.004528,0.004341,0.004307],[0.005625,0.006156,0.006010],[0.006628,0.008293,0.008161],[0.007551,0.010738,0.010790],
    [0.008382,0.013482,0.013941],[0.009111,0.016520,0.017662],[0.009727,0.019846,0.022009],[0.010223,0.023452,0.027035],
    [0.010593,0.027331,0.032799],[0.010833,0.031475,0.039361],[0.010941,0.035875,0.046415],[0.010918,0.040520,0.053597],
    [0.010768,0.045158,0.060914],[0.010492,0.049708,0.068367],[0.010098,0.054171,0.075954],[0.009594,0.058549,0.083672],
    [0.008989,0.062840,0.091521],[0.008297,0.067046,0.099499],[0.007530,0.071165,0.107603],[0.006704,0.075196,0.115830],
    [0.005838,0.079140,0.124178],[0.004949,0.082994,0.132643],[0.004062,0.086758,0.141223],[0.003198,0.090430,0.149913],
    [0.002382,0.094010,0.158711],[0.001643,0.097494,0.167612],[0.001009,0.100883,0.176612],[0.000514,0.104174,0.185704],
    [0.000187,0.107366,0.194886],[0.000066,0.110457,0.204151],[0.000186,0.113445,0.213496],[0.000587,0.116329,0.222914],
    [0.001309,0.119106,0.232397],[0.002394,0.121776,0.241942],[0.003886,0.124336,0.251542],[0.005831,0.126784,0.261189],
    [0.008276,0.129120,0.270876],[0.011268,0.131342,0.280598],[0.014859,0.133447,0.290345],[0.019100,0.135435,0.300111],
    [0.024043,0.137305,0.309888],[0.029742,0.139054,0.319669],[0.036252,0.140683,0.329441],[0.043507,0.142189,0.339203],
    [0.050922,0.143571,0.348942],[0.058432,0.144831,0.358649],[0.066041,0.145965,0.368319],[0.073744,0.146974,0.377938],
    [0.081541,0.147858,0.387501],[0.089431,0.148616,0.396998],[0.097411,0.149248,0.406419],[0.105479,0.149754,0.415755],
    [0.113634,0.150134,0.424998],[0.121873,0.150389,0.434139],[0.130192,0.150521,0.443167],[0.138591,0.150528,0.452075],
    [0.147065,0.150413,0.460852],[0.155614,0.150175,0.469493],[0.164232,0.149818,0.477985],[0.172917,0.149343,0.486322],
    [0.181666,0.148751,0.494494],[0.190476,0.148046,0.502493],[0.199344,0.147229,0.510313],[0.208267,0.146302,0.517944],
    [0.217242,0.145267,0.525380],[0.226264,0.144131,0.532613],[0.235331,0.142894,0.539635],[0.244440,0.141559,0.546442],
    [0.253587,0.140131,0.553026],[0.262769,0.138615,0.559381],[0.271981,0.137016,0.565500],[0.281222,0.135335,0.571381],
    [0.290487,0.133581,0.577017],[0.299774,0.131757,0.582404],[0.309080,0.129867,0.587538],[0.318399,0.127920,0.592415],
    [0.327730,0.125921,0.597032],[0.337069,0.123877,0.601385],[0.346413,0.121793,0.605474],[0.355758,0.119678,0.609295],
    [0.365102,0.117540,0.612846],[0.374443,0.115386,0.616127],[0.383774,0.113226,0.619138],[0.393096,0.111066,0.621876],
    [0.402404,0.108918,0.624343],[0.411694,0.106794,0.626540],[0.420967,0.104698,0.628466],[0.430217,0.102645,0.630123],
    [0.439442,0.100647,0.631513],[0.448637,0.098717,0.632638],[0.457805,0.096861,0.633499],[0.466940,0.095095,0.634100],
    [0.476040,0.093433,0.634443],[0.485102,0.091885,0.634532],[0.494125,0.090466,0.634370],[0.503104,0.089190,0.633962],
    [0.512041,0.088067,0.633311],[0.520931,0.087108,0.632420],[0.529773,0.086329,0.631297],[0.538564,0.085738,0.629944],
    [0.547302,0.085346,0.628367],[0.555986,0.085162,0.626572],[0.564615,0.085190,0.624563],[0.573187,0.085439,0.622345],
    [0.581698,0.085913,0.619926],[0.590149,0.086615,0.617311],[0.598538,0.087543,0.614503],[0.606862,0.088700,0.611511],
    [0.615120,0.090084,0.608343],[0.623312,0.091690,0.605001],[0.631438,0.093511,0.601489],[0.639492,0.095546,0.597821],
    [0.647476,0.097787,0.593999],[0.655389,0.100226,0.590028],[0.663230,0.102856,0.585914],[0.670995,0.105669,0.581667],
    [0.678686,0.108658,0.577291],[0.686302,0.111813,0.572790],[0.693840,0.115129,0.568175],[0.701300,0.118597,0.563449],
    [0.708682,0.122209,0.558616],[0.715984,0.125959,0.553687],[0.723206,0.129840,0.548666],[0.730346,0.133846,0.543558],
    [0.737406,0.137970,0.538366],[0.744382,0.142209,0.533101],[0.751274,0.146556,0.527767],[0.758082,0.151008,0.522369],
    [0.764805,0.155559,0.516912],[0.771443,0.160206,0.511402],[0.777995,0.164946,0.505845],[0.784459,0.169774,0.500246],
    [0.790836,0.174689,0.494607],[0.797125,0.179688,0.488935],[0.803325,0.184767,0.483238],[0.809435,0.189925,0.477518],
    [0.815455,0.195160,0.471781],[0.821384,0.200471,0.466028],[0.827222,0.205854,0.460267],[0.832968,0.211308,0.454505],
    [0.838621,0.216834,0.448738],[0.844181,0.222428,0.442979],[0.849647,0.228090,0.437230],[0.855019,0.233819,0.431491],
    [0.860295,0.239613,0.425771],[0.865475,0.245471,0.420074],[0.870558,0.251393,0.414403],[0.875545,0.257380,0.408759],
    [0.880433,0.263427,0.403152],[0.885223,0.269535,0.397585],[0.889913,0.275705,0.392058],[0.894503,0.281934,0.386578],
    [0.898993,0.288222,0.381152],[0.903381,0.294569,0.375781],[0.907667,0.300974,0.370469],[0.911849,0.307435,0.365223],
    [0.915928,0.313953,0.360048],[0.919902,0.320527,0.354948],[0.923771,0.327155,0.349928],[0.927533,0.333838,0.344994],
    [0.931188,0.340576,0.340149],[0.934736,0.347366,0.335403],[0.938175,0.354207,0.330762],[0.941504,0.361101,0.326229],
    [0.944723,0.368045,0.321814],[0.947831,0.375039,0.317523],[0.950826,0.382083,0.313364],[0.953709,0.389175,0.309345],
    [0.956478,0.396314,0.305477],[0.959133,0.403499,0.301766],[0.961671,0.410731,0.298221],[0.964093,0.418008,0.294853],
    [0.966399,0.425327,0.291676],[0.968586,0.432690,0.288696],[0.970654,0.440095,0.285926],[0.972603,0.447540,0.283380],
    [0.974431,0.455025,0.281067],[0.976139,0.462547,0.279003],[0.977725,0.470107,0.277198],[0.979188,0.477703,0.275666],
    [0.980529,0.485332,0.274422],[0.981747,0.492995,0.273476],[0.982840,0.500690,0.272842],[0.983808,0.508415,0.272532],
    [0.984653,0.516168,0.272560],[0.985373,0.523948,0.272937],[0.985966,0.531754,0.273673],[0.986436,0.539582,0.274779],
    [0.986780,0.547434,0.276264],[0.986998,0.555305,0.278135],[0.987091,0.563195,0.280401],[0.987061,0.571100,0.283066],
    [0.986907,0.579019,0.286137],[0.986629,0.586950,0.289615],[0.986229,0.594891,0.293503],[0.985709,0.602839,0.297802],
    [0.985069,0.610792,0.302512],[0.984310,0.618748,0.307632],[0.983435,0.626704,0.313159],[0.982445,0.634657,0.319089],
    [0.981341,0.642606,0.325420],[0.980130,0.650546,0.332144],[0.978812,0.658475,0.339257],[0.977392,0.666391,0.346753],
    [0.975870,0.674290,0.354625],[0.974252,0.682170,0.362865],[0.972545,0.690026,0.371466],[0.970750,0.697856,0.380419],
    [0.968873,0.705658,0.389718],[0.966921,0.713426,0.399353],[0.964901,0.721157,0.409313],[0.962815,0.728851,0.419594],
    [0.960677,0.736500,0.430181],[0.958490,0.744103,0.441070],[0.956263,0.751656,0.452248],[0.954009,0.759153,0.463702],
    [0.951732,0.766595,0.475429],[0.949445,0.773974,0.487414],[0.947158,0.781289,0.499647],[0.944885,0.788535,0.512116],
    [0.942634,0.795709,0.524811],[0.940423,0.802807,0.537717],[0.938261,0.809825,0.550825],[0.936163,0.816760,0.564121],
    [0.934146,0.823608,0.577591],[0.932224,0.830366,0.591220],[0.930412,0.837031,0.604997],[0.928727,0.843599,0.618904],
    [0.927187,0.850066,0.632926],[0.925809,0.856432,0.647047],[0.924610,0.862691,0.661249],[0.923607,0.868843,0.675517],
    [0.922820,0.874884,0.689832],[0.922265,0.880812,0.704174],[0.921962,0.886626,0.718523],[0.921930,0.892323,0.732859],
    [0.922183,0.897903,0.747163],[0.922741,0.903364,0.761410],[0.923620,0.908706,0.775580],[0.924837,0.913928,0.789648],
    [0.926405,0.919031,0.803590],[0.928340,0.924015,0.817381],[0.930655,0.928881,0.830995],[0.933360,0.933631,0.844405],
    [0.936466,0.938267,0.857583],[0.939982,0.942791,0.870499],[0.943914,0.947207,0.883122],[0.948267,0.951519,0.895421],
    [0.953044,0.955732,0.907359],[0.958246,0.959852,0.918901],[0.963869,0.963887,0.930004],[0.969909,0.967845,0.940623],
    [0.976355,0.971737,0.950704],[0.983195,0.975580,0.960181],[0.990402,0.979395,0.968966],[0.997930,0.983217,0.976920]
  ];

  // Colormap definitions
  const COLORMAPS = {
    grayscale: buildGray,
    viridis: ()=>buildGradient([[68,1,84],[59,82,139],[33,145,140],[94,201,98],[253,231,37]]),
    plasma: ()=>buildGradient([[13,8,135],[126,3,168],[204,71,120],[248,149,64],[240,249,33]]),
    inferno: ()=>buildGradient([[0,0,4],[66,10,104],[147,81,58],[221,81,10],[252,255,164]]),
    magma: ()=>buildGradient([[0,0,4],[59,15,112],[140,41,129],[222,73,104],[254,159,109],[252,253,191]]),
    jet: ()=>buildGradient([[0,0,127],[0,0,255],[0,255,255],[0,255,0],[255,255,0],[255,0,0],[127,0,0]]),
    hot: ()=>buildGradient([[0,0,0],[255,0,0],[255,255,0],[255,255,255]]),
    cool: ()=>buildGradient([[0,255,255],[255,0,255]]),
    parula: ()=>buildGradient([[53,42,135],[15,92,221],[0,166,255],[255,237,0],[255,77,0]]),
    roseus: ()=>buildFromData(ROSEUS_DATA)
  };
  
  // Initialize colormap
  buildGray();
  
  /* ============================================
     ELEMENT REFERENCES
     ============================================ */
  const els = {
    fileIn: document.getElementById('fileIn'),
    fftSize: document.getElementById('fftSize'),
    dynRange: document.getElementById('dynRange'),
    scale: document.getElementById('scale'),
    minHz: document.getElementById('minHz'),
    maxHz: document.getElementById('maxHz'),
    pxH: document.getElementById('pxH'),
    pxPerSec: document.getElementById('pxPerSec'),
    overlapPercent: document.getElementById('overlapPercent'),
    windowFunction: document.getElementById('windowFunction'),
    colormap: document.getElementById('colormap'),
    btnMakeInvertible: document.getElementById('btnMakeInvertible'),
    btnRenderNow: document.getElementById('btnRenderNow'),
    btnDownload: document.getElementById('btnDownload'),
    btnCopyClipboard: document.getElementById('btnCopyClipboard'),
    heavyNote: document.getElementById('heavyNote'),
    status: document.getElementById('status'),
    cursor: document.getElementById('cursor'),
    specWrap: document.getElementById('specWrap'),
    cSpec: document.getElementById('specCanvas'),
    pxHLabel: document.getElementById('pxHLabel'),
    pxPerSecLabel: document.getElementById('pxPerSecLabel'),
    btnRecord: document.getElementById('btnRecord'),
    recTimer: document.getElementById('recTimer'),
    btnSaveRecording: document.getElementById('btnSaveRecording'),
    diagDuration: document.getElementById('diagDuration'),
    diagSampleRate: document.getElementById('diagSampleRate')
  };
  
  /* ============================================
     GLOBAL STATE
     ============================================ */
  let audioBuffer = null;
  let meta = null;
  let offscreen = null;
  let zoomX = 1, zoomY = 1;
  let wasOptimized = false;
  let mediaRecorder = null;
  let recordedChunks = [];
  let recTimerInterval = null;
  let lastRecordingBlob = null;
  let lastRecordingMime = null;
  let liveAnalyser = null;
  let liveAudioCtx = null;
  let liveAnimFrame = null;
  let liveColumn = 0;
  
  /* ============================================
     INVERTIBLE MODE FUNCTIONS
     ============================================ */
  
  /**
   * Compute invertible layout parameters
   * For all scales, height = FFT bin count ensures no frequency detail is lost.
   * For perceptual scales (Mel/Log/Bark), this means low frequencies get extra
   * resolution (redundant but lossless), while high frequencies are preserved.
   * @returns {Object} Invertible parameters
   */
  function computeInvertible(){
    const sr = (meta && meta.sampleRate) || 48000;
    const N = Number(els.fftSize.value)||2048;
    const scale = els.scale ? els.scale.value : 'linear';
    // Get overlap from UI (default 75%)
    const overlapPct = Number(els.overlapPercent?.value) || 75;
    const hop = Math.max(1, Math.round(N * (1 - overlapPct / 100)));
    const maxHz = Number(els.maxHz.value)||Math.floor(sr/2);
    const minHz = Number(els.minHz.value);

    // Calculate number of FFT bins in the frequency range
    const kMin = Math.ceil(minHz * N / sr);
    const kMax = Math.floor(maxHz * N / sr);
    const bins = Math.max(1, kMax - kMin + 1);

    let height;
    if(scale === 'linear' || scale === 'log') {
      // For linear and log: use exact FFT bin count
      height = bins;
    } else if(scale === 'mel') {
      // For Mel: use Mel range, but cap at bin count for practical file sizes
      // Mel range gives natural perceptual resolution
      const melRange = Math.ceil(hzToMel(maxHz) - hzToMel(Math.max(1, minHz)));
      // Use the smaller of: Mel range or FFT bin count
      // Mel range is often smaller and more practical
      height = Math.min(melRange, bins);
      // Ensure minimum of 64 for usable resolution
      height = Math.max(64, height);
    } else if(scale === 'bark') {
      // For Bark: ~24 bands cover the full range, but use more for detail
      const barkRange = Math.ceil(hzToBark(maxHz) - hzToBark(Math.max(1, minHz)));
      // Bark range is small (0-24), so multiply by ~10 for practical resolution
      height = Math.min(barkRange * 10, bins);
      height = Math.max(64, height);
    } else {
      height = bins;
    }

    const pxPerSec = sr / hop;
    return {sr, N, hop, minHz, maxHz, height, pxPerSec, scale, bins};
  }

  /**
   * Apply invertible configuration
   */
  function applyInvertibleOnce(){
    wasOptimized = true;
    const inv = computeInvertible();
    if(els.minHz) els.minHz.value = inv.minHz;
    if(els.maxHz) els.maxHz.value = inv.maxHz;
    if(els.pxH) els.pxH.value = inv.height;
    if(els.pxPerSec) els.pxPerSec.value = inv.pxPerSec.toFixed(2);
    
    scheduleRender();
  }
  
  // Make Invertible button handler - works for all scales
  if(els.btnMakeInvertible){
    els.btnMakeInvertible.addEventListener('click', ()=>{
      const inv = computeInvertible();
      applyInvertibleOnce();
      // Show scale-specific status message
      if(inv.scale === 'linear') {
        els.status.textContent = `Optimized: ${inv.height} rows (1:1 FFT bins)`;
      } else if(inv.scale === 'mel') {
        els.status.textContent = `Optimized for Mel: ${inv.height} rows (${inv.bins} FFT bins)`;
      } else if(inv.scale === 'bark') {
        els.status.textContent = `Optimized for Bark: ${inv.height} rows (${inv.bins} FFT bins)`;
      } else if(inv.scale === 'log') {
        els.status.textContent = `Optimized for Log: ${inv.height} rows (1:1 FFT bins)`;
      } else {
        els.status.textContent = 'Optimized dimensions set';
      }
    });
  }
  
  // Double-click label handlers to set ideal values
  if(els.pxHLabel){
    els.pxHLabel.addEventListener('dblclick', ()=>{
      const inv = computeInvertible();
      els.pxH.value = inv.height;
      if(audioBuffer) scheduleRender();
    });
  }
  
  if(els.pxPerSecLabel){
    els.pxPerSecLabel.addEventListener('dblclick', ()=>{
      const inv = computeInvertible();
      els.pxPerSec.value = inv.pxPerSec.toFixed(2);
      if(audioBuffer) scheduleRender();
    });
  }
  
  // Prevent inputs from triggering the label double-click behavior
  [els.pxH, els.pxPerSec].forEach(input => {
    input.addEventListener('dblclick', e => {
      e.stopPropagation(); // stops bubbling up to label
    });
  });

  // Reset wasOptimized when user manually changes dimensions or scale
  if(els.pxH){
    els.pxH.addEventListener('input', ()=>{
      wasOptimized = false;
    });
  }
  
  if(els.pxPerSec){
    els.pxPerSec.addEventListener('input', ()=>{
      wasOptimized = false;
    });
  }

  if(els.scale){
    els.scale.addEventListener('change', ()=>{
      wasOptimized = false;
    });
  }

  // Update px_per_sec when overlap changes
  if(els.overlapPercent){
    els.overlapPercent.addEventListener('change', ()=>{
      if(audioBuffer && meta){
        const sr = meta.sampleRate;
        const N = Number(els.fftSize.value) || 2048;
        const overlapPct = Number(els.overlapPercent.value);
        const hop = Math.max(1, Math.round(N * (1 - overlapPct / 100)));
        const pxPerSec = sr / hop;
        els.pxPerSec.value = pxPerSec.toFixed(2);
        scheduleRender();
      }
    });
  }

  /* ============================================
     COLORMAP CHANGE HANDLER
     ============================================ */
  if(els.colormap){
    els.colormap.addEventListener('change', ()=>{
      const cm = els.colormap.value;
      if(COLORMAPS[cm]){
        COLORMAPS[cm]();
        if(offscreen && offscreen.gray8){
          renderOffscreenToCanvas();
        }
      }
    });
  }
  
  /* ============================================
     INVERT COLORS HANDLER
     ============================================ */
  const invertChk = document.getElementById('invertColors');
  if(invertChk){
    invertChk.addEventListener('change', ()=>{
      if(offscreen && offscreen.gray8){
        renderOffscreenToCanvas();
      }
    });
  }

  const srgbGammaChk = document.getElementById('srgbGamma');
  if(srgbGammaChk){
    srgbGammaChk.addEventListener('change', ()=>{
      if(audioBuffer) scheduleRender();
    });
  }

  // Border and Info Margin checkboxes re-render preview (no STFT recompute needed)
  ['printBorder','printInfo'].forEach(id=>{
    const chk = document.getElementById(id);
    if(chk) chk.addEventListener('change', ()=>{
      if(offscreen && offscreen.gray8) renderOffscreenToCanvas();
    });
  });

  /* ============================================
     FILE INPUT HANDLER
     ============================================ */
  if(els.fileIn){
    els.fileIn.addEventListener('change', async (e)=>{
      const file = e.target.files[0];
      if(!file) return;
      
      try{
        els.status.textContent = 'Loading audio...';
        if(els.btnSaveRecording) els.btnSaveRecording.style.display = 'none';
        lastRecordingBlob = null;
        const ab = await file.arrayBuffer();
        const actx = new (window.AudioContext || window.webkitAudioContext)();
        audioBuffer = await actx.decodeAudioData(ab);
        
        meta = {
          sampleRate: audioBuffer.sampleRate,
          duration: audioBuffer.duration,
          channels: audioBuffer.numberOfChannels
        };
        wasOptimized = false;

        if(els.diagDuration) els.diagDuration.value = meta.duration.toFixed(3) + ' s';
        if(els.diagSampleRate) els.diagSampleRate.value = meta.sampleRate + ' Hz';
        els.status.textContent = `Loaded: ${meta.duration.toFixed(2)}s, ${meta.sampleRate}Hz, ${meta.channels}ch`;

        // Auto-set maxHz if 0
        if(Number(els.maxHz.value)===0){
          els.maxHz.value = String(Math.floor(meta.sampleRate/2));
        }
        
        // Trigger render
        scheduleRender();
      }catch(err){
        els.status.textContent = 'Error loading audio: ' + err.message;
        console.error(err);
      }
    });
  }

  /* ============================================
     LIVE SPECTROGRAM VISUALIZATION
     ============================================ */
  function startLiveSpectrogram(stream){
    liveAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const source = liveAudioCtx.createMediaStreamSource(stream);
    liveAnalyser = liveAudioCtx.createAnalyser();
    liveAnalyser.fftSize = Number(els.fftSize.value) || 2048;
    liveAnalyser.smoothingTimeConstant = 0;
    source.connect(liveAnalyser);

    const bins = liveAnalyser.frequencyBinCount;
    const canvasW = 800;
    els.cSpec.width = canvasW;
    els.cSpec.height = bins;
    const ctx = els.cSpec.getContext('2d', {willReadFrequently: true});
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvasW, bins);
    liveColumn = 0;

    const dataArray = new Float32Array(bins);
    const dynRange = Number(els.dynRange.value) || 80;
    const invertNow = !(document.getElementById('invertColors')?.checked);
    const colData = new Uint8ClampedArray(bins * 4);

    function drawLiveColumn(){
      liveAnalyser.getFloatFrequencyData(dataArray);

      for(let i = 0; i < bins; i++){
        // AnalyserNode returns dB values (typically -100 to 0)
        const db = dataArray[i];
        const norm = Math.max(0, Math.min(1, (db + dynRange) / dynRange));
        const gray = Math.round(norm * 255);
        const v = invertNow ? (255 - gray) : gray;
        const lutIdx = v * 4;
        // Flip vertically: low freq at bottom
        const row = (bins - 1 - i);
        colData[row * 4]     = LUT[lutIdx];
        colData[row * 4 + 1] = LUT[lutIdx + 1];
        colData[row * 4 + 2] = LUT[lutIdx + 2];
        colData[row * 4 + 3] = 255;
      }

      const ctx = els.cSpec.getContext('2d', {willReadFrequently: true});
      const colImage = new ImageData(colData, 1, bins);

      if(liveColumn < canvasW){
        ctx.putImageData(colImage, liveColumn, 0);
        liveColumn++;
      } else {
        // Scroll left: shift canvas content 1px left, draw new column at right edge
        ctx.drawImage(els.cSpec, -1, 0);
        ctx.putImageData(colImage, canvasW - 1, 0);
      }

      liveAnimFrame = requestAnimationFrame(drawLiveColumn);
    }

    liveAnimFrame = requestAnimationFrame(drawLiveColumn);
  }

  function stopLiveSpectrogram(){
    if(liveAnimFrame){
      cancelAnimationFrame(liveAnimFrame);
      liveAnimFrame = null;
    }
    if(liveAudioCtx){
      liveAudioCtx.close().catch(()=>{});
      liveAudioCtx = null;
    }
    liveAnalyser = null;
    liveColumn = 0;
  }

  /* ============================================
     MICROPHONE RECORDING
     ============================================ */
  if(els.btnRecord){
    // Disable record button if microphone API unavailable (requires HTTPS or localhost)
    if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
      els.btnRecord.disabled = true;
      els.btnRecord.title = 'Recording requires HTTPS or localhost';
    }

    els.btnRecord.addEventListener('click', async ()=>{
      // If currently recording, stop
      if(mediaRecorder && mediaRecorder.state === 'recording'){
        mediaRecorder.stop();
        return;
      }

      // Start recording
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        recordedChunks = [];

        mediaRecorder = new MediaRecorder(stream);

        mediaRecorder.addEventListener('dataavailable', (e)=>{
          if(e.data.size > 0) recordedChunks.push(e.data);
        });

        mediaRecorder.addEventListener('stop', async ()=>{
          // Stop live visualization
          stopLiveSpectrogram();

          // Stop mic access
          stream.getTracks().forEach(t => t.stop());

          // Reset UI
          els.btnRecord.textContent = '‚è∫ Record';
          els.btnRecord.classList.remove('recording');
          els.recTimer.style.display = 'none';
          clearInterval(recTimerInterval);

          if(recordedChunks.length === 0) return;

          try{
            els.status.textContent = 'Processing recording...';
            const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
            lastRecordingBlob = blob;
            lastRecordingMime = mediaRecorder.mimeType;
            if(els.btnSaveRecording) els.btnSaveRecording.style.display = '';
            const ab = await blob.arrayBuffer();
            const actx = new (window.AudioContext || window.webkitAudioContext)();
            audioBuffer = await actx.decodeAudioData(ab);

            meta = {
              sampleRate: audioBuffer.sampleRate,
              duration: audioBuffer.duration,
              channels: audioBuffer.numberOfChannels
            };
            wasOptimized = false;

            if(els.diagDuration) els.diagDuration.value = meta.duration.toFixed(3) + ' s';
            if(els.diagSampleRate) els.diagSampleRate.value = meta.sampleRate + ' Hz';
            els.status.textContent = `Recorded: ${meta.duration.toFixed(2)}s, ${meta.sampleRate}Hz, ${meta.channels}ch`;

            if(Number(els.maxHz.value) === 0){
              els.maxHz.value = String(Math.floor(meta.sampleRate / 2));
            }

            scheduleRender();
          }catch(err){
            els.status.textContent = 'Error processing recording: ' + err.message;
            console.error(err);
          }
        });

        mediaRecorder.start();
        startLiveSpectrogram(stream);

        // Update UI
        els.btnRecord.textContent = '‚èπ Stop';
        els.btnRecord.classList.add('recording');
        const startTime = Date.now();
        els.recTimer.style.display = '';
        els.recTimer.textContent = '0:00';
        recTimerInterval = setInterval(()=>{
          const s = Math.floor((Date.now() - startTime) / 1000);
          const m = Math.floor(s / 60);
          els.recTimer.textContent = m + ':' + String(s % 60).padStart(2, '0');
        }, 250);

        els.status.textContent = 'Recording...';
      }catch(err){
        els.status.textContent = 'Microphone access denied or unavailable.';
        console.error(err);
      }
    });
  }

  /* ============================================
     SAVE RECORDING
     ============================================ */
  if(els.btnSaveRecording){
    els.btnSaveRecording.addEventListener('click', ()=>{
      if(!lastRecordingBlob) return;
      const ext = (lastRecordingMime || '').includes('webm') ? 'webm'
                : (lastRecordingMime || '').includes('ogg') ? 'ogg'
                : (lastRecordingMime || '').includes('mp4') ? 'mp4' : 'wav';
      const url = URL.createObjectURL(lastRecordingBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'recording.' + ext;
      a.click();
      URL.revokeObjectURL(url);
    });
  }

  /* ============================================
     RENDER SCHEDULING
     ============================================ */
  let renderTimeout = null;
  
  function scheduleRender(){
    if(renderTimeout) clearTimeout(renderTimeout);
    
    if(!audioBuffer) return;
    
    // Check if job is large (estimate frame count using same formula as render)
    const fftSize = Number(els.fftSize.value) || 2048;
    const overlapPct = Number(els.overlapPercent?.value) || 75;
    const hop = Math.max(1, Math.round(fftSize * (1 - overlapPct / 100)));
    const samples = Math.round(meta.duration * meta.sampleRate);
    const estimatedFrames = Math.max(1, Math.floor((samples - fftSize)/hop) + 1);
    const w = estimatedFrames;
    const h = Number(els.pxH.value);
    const isHeavy = (w*h > 4000000);
    
    if(isHeavy){
      els.btnRenderNow.style.display = 'inline-block';
      els.heavyNote.style.display = 'block';
      els.status.textContent = 'Large job detected. Click "Render Now" to proceed.';
    }else{
      els.btnRenderNow.style.display = 'none';
      els.heavyNote.style.display = 'none';
      renderTimeout = setTimeout(()=>renderSpectrogram(), 300);
    }
  }
  
  // Manual render button
  if(els.btnRenderNow){
    els.btnRenderNow.addEventListener('click', ()=>{
      renderSpectrogram();
    });
  }
  
  // Auto-schedule on parameter changes
  ['fftSize','dynRange','scale','minHz','maxHz','pxH','pxPerSec','windowFunction'].forEach(id=>{
    if(els[id]){
      els[id].addEventListener('change', ()=>{
        if(audioBuffer) scheduleRender();
      });
    }
  });
  
  /* ============================================
     sRGB GAMMA TRANSFER FUNCTION
     ============================================ */
  function linearToSRGB(x){
    return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1.0 / 2.4) - 0.055;
  }

  /* ============================================
     SPECTROGRAM RENDERING
     ============================================ */
  function renderSpectrogram(){
    if(!audioBuffer) return;
    
    els.status.textContent = 'Rendering...';
    els.btnDownload.disabled = true;
    if(els.btnCopyClipboard) els.btnCopyClipboard.disabled = true;
    
    // Get parameters
    const fftSize = Number(els.fftSize.value);
    const overlapPct = Number(els.overlapPercent?.value) || 75;
    const hop = Math.max(1, Math.round(fftSize * (1 - overlapPct / 100)));
    const dynRange = Number(els.dynRange.value);

    const scaleType = els.scale.value;
    const nyquist = meta.sampleRate/2;
    const isLog = (scaleType === 'log');
    const isMel = (scaleType === 'mel');
    const isBark = (scaleType === 'bark');
    const minHz = Number(els.minHz.value);
    const maxHz = Number(els.maxHz.value);
    const effMinHz = (isLog || isMel || isBark) ? Math.max(1, minHz) : minHz;
    const effMaxHz = maxHz>0 ? Math.min(maxHz, nyquist) : nyquist;
    const pxH = Number(els.pxH.value);
    const pxPerSec = Number(els.pxPerSec.value);
    
    
    // Mix to mono
    let mono = new Float32Array(audioBuffer.length);
    for(let ch=0; ch<audioBuffer.numberOfChannels; ch++){
      const chData = audioBuffer.getChannelData(ch);
      for(let i=0; i<mono.length; i++){
        mono[i] += chData[i];
      }
    }
    for(let i=0; i<mono.length; i++){
      mono[i] /= audioBuffer.numberOfChannels;
    }
    
    // Get window function
    const windowType = els.windowFunction?.value || 'hann';
    let window;
    if(windowType === 'hamming') {
      window = hamming(fftSize);
    } else if(windowType === 'blackman') {
      window = blackman(fftSize);
    } else if(windowType === 'rectangular') {
      window = rectangular(fftSize);
    } else {
      window = hann(fftSize);
    }

    // Zero-pad mono so (length - fftSize) is exactly divisible by hop
    const remainder = (mono.length - fftSize) % hop;
    if(remainder > 0){
      const padAmount = hop - remainder;
      const padded = new Float32Array(mono.length + padAmount);
      padded.set(mono);
      mono = padded;
    }

    // Compute STFT
    const frames = (mono.length - fftSize)/hop + 1;
    const bins = fftSize/2+1;
    
    const mag = new Float32Array(frames*bins);
    const re = new Float32Array(fftSize);
    const im = new Float32Array(fftSize);
    
    for(let f=0; f<frames; f++){
      const offset = f*hop;
      for(let i=0; i<fftSize; i++){
        re[i] = (offset+i < mono.length) ? mono[offset+i]*window[i] : 0;
        im[i] = 0;
      }
      FFT(fftSize, re, im);
      for(let b=0; b<bins; b++){
        mag[f*bins+b] = Math.sqrt(re[b]*re[b] + im[b]*im[b]);
      }
    }

    // Find global max
    let globalMax = 0;
    for(let i=0; i<mag.length; i++){
      if(mag[i]>globalMax) globalMax = mag[i];
    }
    if(globalMax<1e-12) globalMax=1e-12;
    
    // Convert to dB
    const magDB = new Float32Array(mag.length);
    for(let i=0; i<mag.length; i++){
      magDB[i] = 20*Math.log10((mag[i]/globalMax)+1e-12);
    }
    
    function freqToY(hz){
      if(isLog){
        const logMin = Math.log(effMinHz);
        const logMax = Math.log(effMaxHz);
        const logHz = Math.log(Math.max(hz, effMinHz));
        return pxH - 1 - Math.round((logHz-logMin)/(logMax-logMin)*(pxH-1));
      }else if(isMel){
        const melMin = hzToMel(effMinHz);
        const melMax = hzToMel(effMaxHz);
        const melHz = hzToMel(Math.max(hz, effMinHz));
        return pxH - 1 - Math.round((melHz-melMin)/(melMax-melMin)*(pxH-1));
      }else if(isBark){
        const barkMin = hzToBark(effMinHz);
        const barkMax = hzToBark(effMaxHz);
        const barkHz = hzToBark(Math.max(hz, effMinHz));
        return pxH - 1 - Math.round((barkHz-barkMin)/(barkMax-barkMin)*(pxH-1));
      }else{
        return pxH - 1 - Math.round((hz-effMinHz)/(effMaxHz-effMinHz)*(pxH-1));
      }
    }
    
    // Use exact STFT frame count as image width (no resampling = perfect invertibility)
    const w = frames;
    const h = pxH;
    const gray8 = new Uint8ClampedArray(w*h);

    // Direct 1:1 mapping from STFT frames to image columns
    for(let x=0; x<w; x++){
      const frameIdx = x; // Direct mapping, no resampling
      
      for(let y=0; y<h; y++){
        // Map y to frequency
        let hz;
        if(isLog){
          const logMin = Math.log(effMinHz);
          const logMax = Math.log(effMaxHz);
          const frac = (h-1-y)/(h-1);
          hz = Math.exp(logMin + frac*(logMax-logMin));
        }else if(isMel){
          const melMin = hzToMel(effMinHz);
          const melMax = hzToMel(effMaxHz);
          const frac = (h-1-y)/(h-1);
          const mel = melMin + frac*(melMax-melMin);
          hz = melToHz(mel);
        }else if(isBark){
          const barkMin = hzToBark(effMinHz);
          const barkMax = hzToBark(effMaxHz);
          const frac = (h-1-y)/(h-1);
          const bark = barkMin + frac*(barkMax-barkMin);
          hz = barkToHz(bark);
        }else{
          hz = effMinHz + (h-1-y)/(h-1)*(effMaxHz-effMinHz);
        }
        const binFloat = (hz/nyquist)*(bins-1);
        const binIdx = Math.min(Math.max(Math.floor(binFloat), 0), bins-2);
        const frac = Math.min(binFloat - binIdx, 1); // Clamp to prevent extrapolation at edges

        // Use nearest-neighbor when optimized (1:1 bin mapping) for sharper spectral lines
        // Use linear interpolation otherwise for smoother low frequencies
        let db;
        if(wasOptimized) {
          // Nearest-neighbor: pick the closer bin
          const nearestBin = (frac < 0.5) ? binIdx : Math.min(binIdx + 1, bins - 1);
          db = magDB[frameIdx*bins + nearestBin];
        } else {
          // Linear interpolation between adjacent bins
          const db1 = magDB[frameIdx*bins + binIdx];
          const db2 = magDB[frameIdx*bins + binIdx + 1];
          db = db1 + frac * (db2 - db1);
        }
        const norm = Math.max(0, Math.min(1, (db+dynRange)/dynRange));
        gray8[y*w+x] = Math.round(norm*255);
      }
    }
    
    // Store offscreen data
    offscreen = { w, h, gray8 };

    // Update pxPerSec to show true value based on hop (sampleRate / hop)
    // This ensures ReSounder can accurately reconstruct timing
    const actualPxPerSec = meta.sampleRate / hop;
    els.pxPerSec.value = actualPxPerSec.toFixed(2);

    // Render to canvas
    renderOffscreenToCanvas();

    // Enable download/copy
    els.btnDownload.disabled = false;
    if(els.btnCopyClipboard) els.btnCopyClipboard.disabled = false;
    els.status.textContent = `Rendered: ${w}x${h} px (${actualPxPerSec.toFixed(1)} px/sec)`;
  }
  
  /* ============================================
     RENDER OFFSCREEN TO CANVAS
     ============================================ */
  function renderOffscreenToCanvas(){
    if(!offscreen || !offscreen.gray8) return;
    
    const w = offscreen.w;
    const h = offscreen.h;
    
    // Apply colormap + optional sRGB gamma encoding
    const rgba = new Uint8ClampedArray(w*h*4);
    const invertNow = !(invertChk && invertChk.checked);
    const applySRGB = !!(document.getElementById('srgbGamma')?.checked);

    for(let i=0; i<w*h; i++){
      const val = offscreen.gray8[i];
      const v = invertNow ? (255-val) : val;
      const lutIdx = v*4;
      let r = LUT[lutIdx], g = LUT[lutIdx+1], b = LUT[lutIdx+2];
      if(applySRGB){
        r = Math.round(linearToSRGB(r/255)*255);
        g = Math.round(linearToSRGB(g/255)*255);
        b = Math.round(linearToSRGB(b/255)*255);
      }
      rgba[i*4] = r;
      rgba[i*4+1] = g;
      rgba[i*4+2] = b;
      rgba[i*4+3] = 255;
    }
    
    // Apply print layout (border + info margin) if enabled
    const previewMeta = {
      sampleRate: String(meta?.sampleRate || 48000),
      fftSize: String(Number(els.fftSize.value) || 2048),
      minHz: String(Number(els.minHz.value) || 0),
      maxHz: String(Number(els.maxHz.value) || 0),
      duration_sec: String(meta?.duration?.toFixed(6) || '0'),
      colormap: String(els.colormap?.value || 'grayscale')
    };
    const layout = applyPrintLayout(rgba, w, h, previewMeta);

    // Update canvas
    els.cSpec.width = layout.width;
    els.cSpec.height = layout.height;
    els.cSpec.style.position = 'absolute';
    els.cSpec.style.left = '0px';
    els.cSpec.style.top = '0px';
    els.cSpec.style.zIndex = '3';

    const ctx = els.cSpec.getContext('2d', {willReadFrequently: true});
    ctx.imageSmoothingEnabled = false;
    ctx.putImageData(new ImageData(new Uint8ClampedArray(layout.rgba), layout.width, layout.height), 0, 0);

    offscreen.imageData = new ImageData(new Uint8ClampedArray(layout.rgba), layout.width, layout.height);
  }
  
  /* ============================================
     INTERACTION HANDLERS
     ============================================ */
  
  
  // Mouse wheel behavior: scroll normally, shift=horizontal scroll, ctrl=zoom both
  if (els.specWrap) {
    els.specWrap.addEventListener('wheel', (e) => {
      if (!offscreen) return;
  
      // Ctrl + wheel => zoom centered on mouse position
      if (e.ctrlKey) {
        e.preventDefault();
      
        const rect = els.cSpec.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
      
        const fracX = mouseX / els.cSpec.width;
        const fracY = mouseY / els.cSpec.height;
      
        const delta = Math.sign(e.deltaY) * 0.1;
      
        const oldZoomX = zoomX;
        const oldZoomY = zoomY;
      
        zoomX = Math.max(0.25, Math.min(16, zoomX * (1 - delta)));
        zoomY = Math.max(0.25, Math.min(8, zoomY * (1 - delta)));
      
        applyZoom();
      
        const newW = els.cSpec.width;
        const newH = els.cSpec.height;
      
        // Adjust scroll so the mouse focus point stays fixed
        els.specWrap.scrollLeft =
          els.specWrap.scrollLeft +
          (newW * fracX - mouseX) -
          (els.cSpec.width / oldZoomX * fracX - mouseX);
      
        els.specWrap.scrollTop =
          els.specWrap.scrollTop +
          (newH * fracY - mouseY) -
          (els.cSpec.height / oldZoomY * fracY - mouseY);
      
        return;
      }
  
      // Shift + wheel => horizontal scroll
      if (e.shiftKey && !e.ctrlKey) {
        e.preventDefault();
        els.specWrap.scrollLeft += e.deltaY; 
        return;
      }
  
      // Wheel alone => normal up/down scrolling
      // Let browser handle it: do NOT preventDefault()
    }, { passive: false });
  }

  // Apply zoom to canvas
  function applyZoom(){
    if(!offscreen) return;
    const baseW = offscreen.w;
    const baseH = offscreen.h;
    const newW = Math.max(200, Math.round(baseW * zoomX));
    const newH = Math.max(200, Math.round(baseH * zoomY));
    els.cSpec.width = newW;
    els.cSpec.height = newH;
    
    // Redraw with zoom
    const ctx = els.cSpec.getContext('2d', {willReadFrequently: true});
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0, 0, newW, newH);
    if(offscreen.imageData){
      // Create temporary canvas with original data
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = offscreen.w;
      tempCanvas.height = offscreen.h;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.putImageData(offscreen.imageData, 0, 0);
      
      // Draw scaled
      ctx.drawImage(tempCanvas, 0, 0, newW, newH);
    }
    
  }
  
  // Pan dragging
  let drag=false, sx=0, sy=0, scrollL=0, scrollT=0;
  if(els.specWrap){
    els.specWrap.addEventListener('mousedown', (e)=>{
      drag=true;
      sx=e.clientX;
      sy=e.clientY;
      scrollL=els.specWrap.scrollLeft;
      scrollT=els.specWrap.scrollTop;
    });
  }
  window.addEventListener('mouseup', ()=> drag=false);
  window.addEventListener('mousemove', (e)=>{
    if(!drag || !els.specWrap) return;
    els.specWrap.scrollLeft = scrollL - (e.clientX - sx);
    els.specWrap.scrollTop = scrollT - (e.clientY - sy);
  });
  
  // Cursor position display
  if(els.cSpec){
    els.cSpec.addEventListener('mousemove', (e)=>{
      if(!offscreen) return;
      
      const rect = els.cSpec.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      const t = (x/els.cSpec.width)*meta.duration;
      
      const scaleType = els.scale.value;
      const isLog = (scaleType === 'log');
      const isMel = (scaleType === 'mel');
      const isBark = (scaleType === 'bark');
      const minHz = Number(els.minHz.value);
      const maxHz = Number(els.maxHz.value) || (meta.sampleRate/2);
      const effMinHz = (isLog || isMel || isBark) ? Math.max(1, minHz) : minHz;
      const h = els.cSpec.height;
      
      let hz;
      if(isLog){
        const logMin = Math.log(effMinHz);
        const logMax = Math.log(maxHz);
        const frac = (h-1-y)/(h-1);
        hz = Math.exp(logMin + frac*(logMax-logMin));
      }else if(isMel){
        const melMin = hzToMel(effMinHz);
        const melMax = hzToMel(maxHz);
        const frac = (h-1-y)/(h-1);
        const mel = melMin + frac*(melMax-melMin);
        hz = melToHz(mel);
      }else if(isBark){
        const barkMin = hzToBark(effMinHz);
        const barkMax = hzToBark(maxHz);
        const frac = (h-1-y)/(h-1);
        const bark = barkMin + frac*(barkMax-barkMin);
        hz = barkToHz(bark);
      }else{
        hz = effMinHz + (h-1-y)/(h-1)*(maxHz-effMinHz);
      }
      els.cursor.textContent = `${fmtTime(t)} ‚Ä¢ ${Math.round(hz)} Hz`;
    });
  }
  
  // Double-click to reset zoom
  if(els.specWrap){
    els.specWrap.addEventListener('dblclick', ()=>{
      zoomX=1;
      zoomY=1;
      if(offscreen){
        els.cSpec.width = offscreen.w;
        els.cSpec.height = offscreen.h;
        renderOffscreenToCanvas();
      }
    });
  }
  
  /* ============================================
     PNG EXPORT FUNCTIONS
     ============================================ */
  
  function _concat(chunks){
    let len=0;
    for(const c of chunks) len+=c.length;
    const out=new Uint8Array(len);
    let pos=0;
    for(const c of chunks){
      out.set(c, pos);
      pos+=c.length;
    }
    return out;
  }
  
  function _crc32(buf){
    const table=new Uint32Array(256);
    for(let i=0;i<256;i++){
      let c=i;
      for(let k=0;k<8;k++) c=(c&1)?(0xedb88320^(c>>>1)):(c>>>1);
      table[i]=c;
    }
    let crc=0xffffffff;
    for(let i=0;i<buf.length;i++){
      crc=table[(crc^buf[i])&0xff]^(crc>>>8);
    }
    return (crc^0xffffffff)>>>0;
  }
  
  function _chunk(type,data){
    const len=data?data.length:0;
    const buf=new Uint8Array(4+4+len+4);
    const dv=new DataView(buf.buffer);
    dv.setUint32(0,len);
    buf.set(type,4);
    if(data) buf.set(data,8);
    const crcData=new Uint8Array(buf.buffer,4,4+len);
    dv.setUint32(8+len,_crc32(crcData));
    return buf;
  }
  
  function _zlibStore(data){
    const bsize=65535;
    const blocks=[];
    let i=0;
    while(i<data.length){
      const chunk=data.subarray(i, Math.min(i+bsize, data.length));
      const isLast=(i+chunk.length>=data.length)?1:0;
      const hdr=new Uint8Array(5);
      hdr[0]=(isLast<<0)|(0<<1);
      hdr[1]=chunk.length&0xff;
      hdr[2]=(chunk.length>>>8)&0xff;
      hdr[3]=(~chunk.length)&0xff;
      hdr[4]=((~chunk.length)>>>8)&0xff;
      blocks.push(hdr,chunk);
      i+=chunk.length;
    }
    const adler=_adler32(data);
    const header=new Uint8Array([0x78,0x01]);
    const footer=new Uint8Array(4);
    new DataView(footer.buffer).setUint32(0,adler);
    return _concat([header,...blocks,footer]);
  }
  
  function _adler32(data){
    let a=1,b=0;
    for(let i=0;i<data.length;i++){
      a=(a+data[i])%65521;
      b=(b+a)%65521;
    }
    return (b<<16)|a;
  }
  
  function encodeRGBA8(w, h, rgba, meta){
    const sig = new Uint8Array([137,80,78,71,13,10,26,10]);
  
    const ihdr = new Uint8Array(13);
    const dv = new DataView(ihdr.buffer);
    dv.setUint32(0,w);
    dv.setUint32(4,h);
    ihdr[8] = 8;  // 8-bit
    ihdr[9] = 6;  // color RGBA
    ihdr[10]=0;
    ihdr[11]=0;
    ihdr[12]=0;
  
    const chunks = [
      sig,
      _chunk(new Uint8Array([73,72,68,82]), ihdr)
    ];
  
    if(meta){
      for(const k in meta){
        const text = new TextEncoder().encode(k + "\x00" + meta[k]);
        chunks.push(_chunk(new Uint8Array([116,69,88,116]), text)); // tEXt
      }
    }
  
    // Each row: filter byte then RGBA data
    const scan = new Uint8Array(h * (1 + w*4));
    let si = 0, di = 0;
    for(let y = 0; y < h; y++){
      scan[di++] = 0;
      for(let x = 0; x < w*4; x++){
        scan[di++] = rgba[si++];
      }
    }
  
    const z = _zlibStore(scan);
    chunks.push(_chunk(new Uint8Array([73,68,65,84]), z)); // IDAT
    chunks.push(_chunk(new Uint8Array([73,69,78,68]), null)); // IEND
  
    return _concat(chunks);
  }

  /* ============================================
     PRINT LAYOUT: BORDER + INFO MARGIN
     ============================================ */
  const PRINT_BORDER_WIDTH = 2;
  const PRINT_INFO_HEIGHT = 24;

  // Wrap spectrogram RGBA with optional border and info text margin.
  // Returns { rgba, width, height } for the final image.
  function applyPrintLayout(specRGBA, specW, specH, metaObj){
    const addBorder = !!(document.getElementById('printBorder')?.checked);
    const addInfo   = !!(document.getElementById('printInfo')?.checked);

    if(!addBorder && !addInfo) return { rgba: specRGBA, width: specW, height: specH };

    const bw = addBorder ? PRINT_BORDER_WIDTH : 0;
    const ih = addInfo ? PRINT_INFO_HEIGHT : 0;
    const totalW = specW + bw * 2;
    const totalH = specH + bw * 2 + ih;

    // Use a temporary canvas to composite everything
    const tc = document.createElement('canvas');
    tc.width = totalW;
    tc.height = totalH;
    const tctx = tc.getContext('2d');

    // Fill background white (visible in border and info areas)
    tctx.fillStyle = '#ffffff';
    tctx.fillRect(0, 0, totalW, totalH);

    // Draw border (black)
    if(addBorder){
      tctx.fillStyle = '#000000';
      // Top
      tctx.fillRect(0, 0, totalW, bw);
      // Bottom (below spectrogram, above info)
      tctx.fillRect(0, bw + specH, totalW, bw);
      // Left
      tctx.fillRect(0, 0, bw, bw * 2 + specH);
      // Right
      tctx.fillRect(totalW - bw, 0, bw, bw * 2 + specH);
    }

    // Draw spectrogram pixels
    const specImgData = new ImageData(new Uint8ClampedArray(specRGBA), specW, specH);
    tctx.putImageData(specImgData, bw, bw);

    // Draw info text in bottom margin
    if(addInfo){
      const infoY = bw * 2 + specH;
      tctx.fillStyle = '#ffffff';
      tctx.fillRect(0, infoY, totalW, ih);

      const sr = metaObj.sampleRate || '48000';
      const fft = metaObj.fftSize || '2048';
      const minF = metaObj.minHz || '0';
      const maxF = metaObj.maxHz || '?';
      const dur = metaObj.duration_sec ? Number(metaObj.duration_sec).toFixed(1) : '?';
      const cmap = metaObj.colormap || 'grayscale';
      const infoText = `${sr}Hz  FFT ${fft}  ${minF}-${maxF}Hz  ${dur}s  ${cmap}`;

      tctx.fillStyle = '#000000';
      tctx.font = '11px monospace';
      tctx.textBaseline = 'middle';
      tctx.textAlign = 'center';
      tctx.fillText(infoText, totalW / 2, infoY + ih / 2);
    }

    // Extract final RGBA
    const finalData = tctx.getImageData(0, 0, totalW, totalH);
    return { rgba: finalData.data, width: totalW, height: totalH };
  }

  // Export button handler
  if(els.btnDownload){
    els.btnDownload.addEventListener('click', ()=>{
      if(!offscreen) return;
      const w = offscreen.w, h = offscreen.h;
      
      // ? 8-bit grayscale export with metadata
      if (!(w > 0 && h > 0)) return;
      
      const invNow = !(document.getElementById('invertColors')?.checked);
      
      // Build RGBA pixel buffer using the colormap LUT (matches preview)
      const applySRGBExp = !!(document.getElementById('srgbGamma')?.checked);
      const rgba = new Uint8ClampedArray(offscreen.gray8.length * 4);
      for (let i = 0; i < offscreen.gray8.length; i++) {
        const v = offscreen.gray8[i];
        const lutIdx = (invNow ? (255 - v) : v) * 4;
        let r = LUT[lutIdx+0], g = LUT[lutIdx+1], b = LUT[lutIdx+2];
        if(applySRGBExp){
          r = Math.round(linearToSRGB(r/255)*255);
          g = Math.round(linearToSRGB(g/255)*255);
          b = Math.round(linearToSRGB(b/255)*255);
        }
        rgba[i*4+0] = r;
        rgba[i*4+1] = g;
        rgba[i*4+2] = b;
        rgba[i*4+3] = 255;
      }
      
      // Calculate hop using same formula as rendering
      const fftSizeVal = Number(els.fftSize.value) || 2048;
      const overlapPctVal = Number(els.overlapPercent?.value) || 75;
      const hopVal = Math.max(1, Math.round(fftSizeVal * (1 - overlapPctVal / 100)));

      const addBorder = !!(document.getElementById('printBorder')?.checked);
      const addInfo = !!(document.getElementById('printInfo')?.checked);

      const metaOut = {
        colormap: String(els.colormap?.value || 'grayscale'),
        invertColors: String(!invNow),
        fftSize: String(fftSizeVal),
        hop: String(hopVal),
        overlapPercent: String(overlapPctVal),
        windowType: String(els.windowFunction?.value || 'hann'),
        sampleRate: String(meta?.sampleRate || 48000),
        dynRange: String(Number(els.dynRange.value)||0),
        scale: String(els.scale?.value || 'linear'),
        melType: 'htk',
        minHz: String(Number(els.minHz.value)||0),
        maxHz: String(Number(els.maxHz.value)||0),
        pxPerSec: String(Number(els.pxPerSec.value)||0),
        optimized: String(wasOptimized),
        srgbGamma: String(!!(document.getElementById('srgbGamma')?.checked)),
        duration_sec: String(meta?.duration?.toFixed(6)||'0'),
        __height: String(h),
        __width: String(w),
        printBorder: String(addBorder),
        printBorderWidth: String(addBorder ? PRINT_BORDER_WIDTH : 0),
        printInfo: String(addInfo),
        printInfoHeight: String(addInfo ? PRINT_INFO_HEIGHT : 0)
      };

      const layout = applyPrintLayout(rgba, w, h, metaOut);
      const png = encodeRGBA8(layout.width, layout.height, layout.rgba, metaOut);
      const blob = new Blob([png], {type:'image/png'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.download = 'spectrogram.png';
      a.href = url;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 2000);
      
      els.status.textContent = `Exported: PNG with metadata`;
    });
  }
  
  /* ============================================
     COPY TO CLIPBOARD
     ============================================ */
  function copySpectrogramToClipboard(){
    if(!offscreen || !offscreen.gray8) return;
    const w = offscreen.w, h = offscreen.h;
    if(!(w > 0 && h > 0)) return;

    const invNow = !(document.getElementById('invertColors')?.checked);

    // Build RGBA pixel buffer using the colormap LUT (same as export)
    const applySRGBClip = !!(document.getElementById('srgbGamma')?.checked);
    const rgba = new Uint8ClampedArray(offscreen.gray8.length * 4);
    for(let i = 0; i < offscreen.gray8.length; i++){
      const v = offscreen.gray8[i];
      const lutIdx = (invNow ? (255 - v) : v) * 4;
      let r = LUT[lutIdx], g = LUT[lutIdx+1], b = LUT[lutIdx+2];
      if(applySRGBClip){
        r = Math.round(linearToSRGB(r/255)*255);
        g = Math.round(linearToSRGB(g/255)*255);
        b = Math.round(linearToSRGB(b/255)*255);
      }
      rgba[i*4]   = r;
      rgba[i*4+1] = g;
      rgba[i*4+2] = b;
      rgba[i*4+3] = 255;
    }

    // Build metadata (same as export)
    const addBorderClip = !!(document.getElementById('printBorder')?.checked);
    const addInfoClip = !!(document.getElementById('printInfo')?.checked);
    const fftSizeVal = Number(els.fftSize.value) || 2048;
    const overlapPctVal = Number(els.overlapPercent?.value) || 75;
    const hopVal = Math.max(1, Math.round(fftSizeVal * (1 - overlapPctVal / 100)));
    const metaOut = {
      colormap: String(els.colormap?.value || 'grayscale'),
      invertColors: String(!invNow),
      fftSize: String(fftSizeVal),
      hop: String(hopVal),
      overlapPercent: String(overlapPctVal),
      windowType: String(els.windowFunction?.value || 'hann'),
      sampleRate: String(meta?.sampleRate || 48000),
      dynRange: String(Number(els.dynRange.value)||0),
      scale: String(els.scale?.value || 'linear'),
      melType: 'htk',
      minHz: String(Number(els.minHz.value)||0),
      maxHz: String(Number(els.maxHz.value)||0),
      pxPerSec: String(Number(els.pxPerSec.value)||0),
      optimized: String(wasOptimized),
      srgbGamma: String(!!(document.getElementById('srgbGamma')?.checked)),
      duration_sec: String(meta?.duration?.toFixed(6)||'0'),
      __height: String(h),
      __width: String(w),
      printBorder: String(addBorderClip),
      printBorderWidth: String(addBorderClip ? PRINT_BORDER_WIDTH : 0),
      printInfo: String(addInfoClip),
      printInfoHeight: String(addInfoClip ? PRINT_INFO_HEIGHT : 0)
    };

    const layout = applyPrintLayout(rgba, w, h, metaOut);
    const png = encodeRGBA8(layout.width, layout.height, layout.rgba, metaOut);
    const blob = new Blob([png], {type: 'image/png'});
    navigator.clipboard.write([
      new ClipboardItem({ 'image/png': blob })
    ]).then(()=>{
      els.status.textContent = 'Copied spectrogram to clipboard (with metadata).';
    }).catch((err)=>{
      els.status.textContent = 'Copy failed: ' + err.message;
    });
  }

  if(els.btnCopyClipboard){
    els.btnCopyClipboard.addEventListener('click', copySpectrogramToClipboard);
  }

  document.addEventListener('keydown', (e)=>{
    if((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'c'){
      if(offscreen){
        e.preventDefault();
        copySpectrogramToClipboard();
      }
    }
  });

  /* ============================================
     INITIALIZATION
     ============================================ */
  
  (function(){
    // Estimate proper initial canvas size so it is visible before zoom/interaction
    const width = Math.max(600, Math.ceil(20 * Number(els.pxPerSec.value)));
    const height = Math.max(300, Number(els.pxH.value));
    els.cSpec.width = width;
    els.cSpec.height = height;
    els.cSpec.style.position='absolute';
    els.cSpec.style.left = '0px';
    els.cSpec.style.top = '0px';
  })();
  </script>

  <!-- License Modal Handler Script -->
  <script>
    (function(){
      const licenseLink = document.getElementById('licenseLink');
      const licenseModal = document.getElementById('licenseModal');
      const licenseOverlay = document.getElementById('licenseOverlay');
      const licenseClose = document.getElementById('licenseClose');

      if(!licenseLink || !licenseModal || !licenseOverlay || !licenseClose) return;

      function showLicense() {
        licenseModal.classList.add('show');
        licenseOverlay.classList.add('show');
      }

      function hideLicense() {
        licenseModal.classList.remove('show');
        licenseOverlay.classList.remove('show');
      }

      licenseLink.addEventListener('click', showLicense);
      licenseClose.addEventListener('click', hideLicense);
      licenseOverlay.addEventListener('click', hideLicense);
    })();
  </script>
</body>
</html>
